Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    INDIVISIBLE
    SLASH

Grammar

Rule 0     S' -> statement
Rule 1     statement -> <empty>
Rule 2     statement -> TYPE COLON decl_names
Rule 3     decl_names -> NAME decl_names_m
Rule 4     decl_names_m -> COMMA NAME decl_names_m
Rule 5     decl_names_m -> <empty>
Rule 6     statement -> TYPE COLON NAME ASSIGN value
Rule 7     statement -> NAME ASSIGN value
Rule 8     statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array
Rule 9     init_array -> L_C_BRACKET R_C_BRACKET
Rule 10    init_array -> L_C_BRACKET init_array_val R_C_BRACKET
Rule 11    init_array_val -> init_array_val COMMA value
Rule 12    init_array_val -> value
Rule 13    init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET
Rule 14    statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value
Rule 15    statement -> NAME NO END NI value WO ADD
Rule 16    statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
Rule 17    statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
Rule 18    init_array2d -> L_C_BRACKET init_array2d_val R_C_BRACKET
Rule 19    init_array2d_val -> init_array2d_val COMMA init_array
Rule 20    init_array2d_val -> init_array
Rule 21    statement -> value WO OUT
Rule 22    params -> <empty>
Rule 23    params -> TYPE COLON NAME params_m
Rule 24    params -> TYPE NO ARRAY COLON NAME params_m
Rule 25    params_m -> COMMA TYPE COLON NAME params_m
Rule 26    params_m -> COMMA TYPE NO ARRAY COLON NAME params_m
Rule 27    params_m -> <empty>
Rule 28    statement -> CIRCLE NAME L_PAREN params R_PAREN
Rule 29    statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN
Rule 30    statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN
Rule 31    args -> <empty>
Rule 32    args -> value args_m
Rule 33    args_m -> COMMA value args_m
Rule 34    args_m -> <empty>
Rule 35    statement -> NAME L_PAREN args R_PAREN
Rule 36    statement -> NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 37    statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 38    statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 39    statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
Rule 40    value -> POW L_PAREN args R_PAREN
Rule 41    statement -> RETURN
Rule 42    statement -> RETURN value
Rule 43    statement -> IF L_PAREN conditional R_PAREN
Rule 44    statement -> ELSEIF L_PAREN conditional R_PAREN
Rule 45    statement -> ELSE
Rule 46    statement -> ENDIF
Rule 47    conditional -> value sign value
Rule 48    sign -> EQUAL
Rule 49    sign -> NOT EQUAL
Rule 50    sign -> NOT2
Rule 51    sign -> LESS
Rule 52    sign -> LESS EQUAL
Rule 53    sign -> LESS_EQUAL
Rule 54    sign -> GREATER
Rule 55    sign -> GREATER EQUAL
Rule 56    sign -> GREATER_EQUAL
Rule 57    conditional -> value GA value TO HITOSHII
Rule 58    conditional -> value GA value TO NOTHITOSHII
Rule 59    conditional -> value GA value DE DIVISIBLE
Rule 60    conditional -> value GA value TO value DE DIVISIBLE
Rule 61    statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN
Rule 62    incdec -> INCREASE
Rule 63    incdec -> DECREASE
Rule 64    statement -> ENDFOR
Rule 65    statement -> WHILE L_PAREN conditional R_PAREN
Rule 66    statement -> DO
Rule 67    value -> NUMBER
Rule 68    value -> MINUS value
Rule 69    value -> FLOAT
Rule 70    value -> NAME
Rule 71    value -> STRING
Rule 72    value -> NAME L_S_BRACKET value R_S_BRACKET
Rule 73    value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE
Rule 74    value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
Rule 75    value -> NAME NO ARR_LEN
Rule 76    value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
Rule 77    value -> L_PAREN value R_PAREN
Rule 78    value -> L_PAREN value R_PAREN NO RESULT
Rule 79    value -> value PLUS value
Rule 80    value -> value MINUS value
Rule 81    value -> value MULTI value
Rule 82    value -> value ASTERISK value
Rule 83    value -> value DIVID value division_tail
Rule 84    division_tail -> NO SHOW
Rule 85    division_tail -> NO REMAINDER
Rule 86    division_tail -> DIVREAL
Rule 87    division_tail -> <empty>
Rule 88    value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
Rule 89    value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
Rule 90    value -> value RSHIFT value
Rule 91    value -> value LSHIFT value
Rule 92    value -> value CONJUNCT value
Rule 93    value -> value LOGICSUM value

Terminals, with rules where they appear

ADD                  : 15 39
ARRAY                : 8 16 16 17 17 24 26 30 38
ARR_LEN              : 75 76
ASSIGN               : 6 7 8 14 16 17 36 37 38
ASTERISK             : 82
BELOW                : 88 89
CIRCLE               : 28 29 30
COLON                : 2 6 8 16 17 17 23 24 25 26 29 30 37 38
COMMA                : 4 11 19 25 26 33
CONJUNCT             : 92
DE                   : 59 60
DECIMAL_P            : 88 89
DECREASE             : 63
DIVID                : 83
DIVISIBLE            : 59 60
DIVREAL              : 86
DO                   : 66
ELSE                 : 45
ELSEIF               : 44
END                  : 15 39
ENDFOR               : 64
ENDIF                : 46
EQUAL                : 48 49 52 55
FLOAT                : 69
FOR                  : 61
GA                   : 57 58 59 60
GLOBAL               : 17
GREATER              : 54 55
GREATER_EQUAL        : 56
HITOSHII             : 57
IF                   : 43
INCREASE             : 62
INDIVISIBLE          : 
KARA                 : 61
KO                   : 13
LESS                 : 51 52
LESS_EQUAL           : 53
LOGICSUM             : 93
LSHIFT               : 91
L_C_BRACKET          : 9 10 13 18
L_PAREN              : 28 29 30 35 36 37 38 39 40 43 44 61 65 77 78 89
L_S_BRACKET          : 14 72 73 74 74 76
MADE                 : 61
MINUS                : 68 80
MULTI                : 81
NAME                 : 3 4 6 7 8 14 15 16 17 23 24 25 26 28 29 30 35 36 36 37 37 38 38 39 39 61 70 72 73 74 75 76
NI                   : 15 39
NO                   : 8 13 13 15 16 17 24 26 30 38 39 39 73 75 76 78 84 85 88 89
NOT                  : 49
NOT2                 : 50
NOTHITOSHII          : 58
NUMBER               : 61 67
OUT                  : 21
PLUS                 : 79
POW                  : 40
REMAINDER            : 85
RESULT               : 78
RETURN               : 41 42
RETURN_VAL           : 39
ROUNDED_UP           : 88 89
RSHIFT               : 90
R_C_BRACKET          : 9 10 13 18
R_PAREN              : 28 29 30 35 36 37 38 39 40 43 44 61 65 77 78 89
R_S_BRACKET          : 14 72 73 74 74 76
SHOW                 : 84
SLASH                : 
STRING               : 71
TO                   : 57 58 60
TYPE                 : 2 6 8 16 17 23 24 25 26 29 30 37 38
UNDEF                : 13
VALUE                : 13 73 88 89
WHILE                : 65
WO                   : 15 21 39 61 88 89
ZUTSU                : 61
error                : 

Nonterminals, with rules where they appear

args                 : 35 36 37 38 39 40
args_m               : 32 33
conditional          : 43 44 65
decl_names           : 2
decl_names_m         : 3 4
division_tail        : 83
incdec               : 61
init_array           : 8 19 20
init_array2d         : 16 17
init_array2d_val     : 18 19
init_array_val       : 10 11
params               : 28 29 30
params_m             : 23 24 25 26
sign                 : 47
statement            : 0
value                : 6 7 11 12 13 14 14 15 21 32 33 42 47 47 57 57 58 58 59 59 60 60 60 61 61 68 72 73 74 74 76 77 78 79 79 80 80 81 81 82 82 83 83 88 89 90 90 91 91 92 92 93 93

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> .
    (2) statement -> . TYPE COLON decl_names
    (6) statement -> . TYPE COLON NAME ASSIGN value
    (7) statement -> . NAME ASSIGN value
    (8) statement -> . TYPE NO ARRAY COLON NAME ASSIGN init_array
    (14) statement -> . NAME L_S_BRACKET value R_S_BRACKET ASSIGN value
    (15) statement -> . NAME NO END NI value WO ADD
    (16) statement -> . TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
    (17) statement -> . GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
    (21) statement -> . value WO OUT
    (28) statement -> . CIRCLE NAME L_PAREN params R_PAREN
    (29) statement -> . CIRCLE TYPE COLON NAME L_PAREN params R_PAREN
    (30) statement -> . CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN
    (35) statement -> . NAME L_PAREN args R_PAREN
    (36) statement -> . NAME ASSIGN NAME L_PAREN args R_PAREN
    (37) statement -> . TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (38) statement -> . TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (39) statement -> . NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (41) statement -> . RETURN
    (42) statement -> . RETURN value
    (43) statement -> . IF L_PAREN conditional R_PAREN
    (44) statement -> . ELSEIF L_PAREN conditional R_PAREN
    (45) statement -> . ELSE
    (46) statement -> . ENDIF
    (61) statement -> . FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN
    (64) statement -> . ENDFOR
    (65) statement -> . WHILE L_PAREN conditional R_PAREN
    (66) statement -> . DO
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    $end            reduce using rule 1 (statement -> .)
    TYPE            shift and go to state 2
    NAME            shift and go to state 3
    GLOBAL          shift and go to state 5
    CIRCLE          shift and go to state 6
    RETURN          shift and go to state 8
    IF              shift and go to state 9
    ELSEIF          shift and go to state 10
    ELSE            shift and go to state 11
    ENDIF           shift and go to state 12
    FOR             shift and go to state 13
    ENDFOR          shift and go to state 15
    WHILE           shift and go to state 16
    DO              shift and go to state 17
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    statement                      shift and go to state 1
    value                          shift and go to state 4

state 1

    (0) S' -> statement .



state 2

    (2) statement -> TYPE . COLON decl_names
    (6) statement -> TYPE . COLON NAME ASSIGN value
    (8) statement -> TYPE . NO ARRAY COLON NAME ASSIGN init_array
    (16) statement -> TYPE . ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
    (37) statement -> TYPE . COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (38) statement -> TYPE . NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    COLON           shift and go to state 22
    NO              shift and go to state 23
    ARRAY           shift and go to state 24


state 3

    (7) statement -> NAME . ASSIGN value
    (14) statement -> NAME . L_S_BRACKET value R_S_BRACKET ASSIGN value
    (15) statement -> NAME . NO END NI value WO ADD
    (35) statement -> NAME . L_PAREN args R_PAREN
    (36) statement -> NAME . ASSIGN NAME L_PAREN args R_PAREN
    (39) statement -> NAME . NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    ASSIGN          shift and go to state 25
    L_S_BRACKET     shift and go to state 26
    NO              shift and go to state 27
    L_PAREN         shift and go to state 28
    WO              reduce using rule 70 (value -> NAME .)
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 4

    (21) statement -> value . WO OUT
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              shift and go to state 29
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 5

    (17) statement -> GLOBAL . COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d

    COLON           shift and go to state 40


state 6

    (28) statement -> CIRCLE . NAME L_PAREN params R_PAREN
    (29) statement -> CIRCLE . TYPE COLON NAME L_PAREN params R_PAREN
    (30) statement -> CIRCLE . TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN

    NAME            shift and go to state 41
    TYPE            shift and go to state 42


state 7

    (77) value -> L_PAREN . value R_PAREN
    (78) value -> L_PAREN . value R_PAREN NO RESULT
    (89) value -> L_PAREN . value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 43

state 8

    (41) statement -> RETURN .
    (42) statement -> RETURN . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    $end            reduce using rule 41 (statement -> RETURN .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 45

state 9

    (43) statement -> IF . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 46


state 10

    (44) statement -> ELSEIF . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 47


state 11

    (45) statement -> ELSE .

    $end            reduce using rule 45 (statement -> ELSE .)


state 12

    (46) statement -> ENDIF .

    $end            reduce using rule 46 (statement -> ENDIF .)


state 13

    (61) statement -> FOR . L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN

    L_PAREN         shift and go to state 48


state 14

    (67) value -> NUMBER .

    WO              reduce using rule 67 (value -> NUMBER .)
    PLUS            reduce using rule 67 (value -> NUMBER .)
    MINUS           reduce using rule 67 (value -> NUMBER .)
    MULTI           reduce using rule 67 (value -> NUMBER .)
    ASTERISK        reduce using rule 67 (value -> NUMBER .)
    DIVID           reduce using rule 67 (value -> NUMBER .)
    NO              reduce using rule 67 (value -> NUMBER .)
    RSHIFT          reduce using rule 67 (value -> NUMBER .)
    LSHIFT          reduce using rule 67 (value -> NUMBER .)
    CONJUNCT        reduce using rule 67 (value -> NUMBER .)
    LOGICSUM        reduce using rule 67 (value -> NUMBER .)
    R_PAREN         reduce using rule 67 (value -> NUMBER .)
    $end            reduce using rule 67 (value -> NUMBER .)
    R_S_BRACKET     reduce using rule 67 (value -> NUMBER .)
    COMMA           reduce using rule 67 (value -> NUMBER .)
    DIVREAL         reduce using rule 67 (value -> NUMBER .)
    GA              reduce using rule 67 (value -> NUMBER .)
    EQUAL           reduce using rule 67 (value -> NUMBER .)
    NOT             reduce using rule 67 (value -> NUMBER .)
    NOT2            reduce using rule 67 (value -> NUMBER .)
    LESS            reduce using rule 67 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 67 (value -> NUMBER .)
    GREATER         reduce using rule 67 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 67 (value -> NUMBER .)
    TO              reduce using rule 67 (value -> NUMBER .)
    DE              reduce using rule 67 (value -> NUMBER .)
    KARA            reduce using rule 67 (value -> NUMBER .)
    MADE            reduce using rule 67 (value -> NUMBER .)
    KO              reduce using rule 67 (value -> NUMBER .)
    R_C_BRACKET     reduce using rule 67 (value -> NUMBER .)


state 15

    (64) statement -> ENDFOR .

    $end            reduce using rule 64 (statement -> ENDFOR .)


state 16

    (65) statement -> WHILE . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 49


state 17

    (66) statement -> DO .

    $end            reduce using rule 66 (statement -> DO .)


state 18

    (40) value -> POW . L_PAREN args R_PAREN

    L_PAREN         shift and go to state 50


state 19

    (68) value -> MINUS . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 51

state 20

    (69) value -> FLOAT .

    WO              reduce using rule 69 (value -> FLOAT .)
    PLUS            reduce using rule 69 (value -> FLOAT .)
    MINUS           reduce using rule 69 (value -> FLOAT .)
    MULTI           reduce using rule 69 (value -> FLOAT .)
    ASTERISK        reduce using rule 69 (value -> FLOAT .)
    DIVID           reduce using rule 69 (value -> FLOAT .)
    NO              reduce using rule 69 (value -> FLOAT .)
    RSHIFT          reduce using rule 69 (value -> FLOAT .)
    LSHIFT          reduce using rule 69 (value -> FLOAT .)
    CONJUNCT        reduce using rule 69 (value -> FLOAT .)
    LOGICSUM        reduce using rule 69 (value -> FLOAT .)
    R_PAREN         reduce using rule 69 (value -> FLOAT .)
    $end            reduce using rule 69 (value -> FLOAT .)
    R_S_BRACKET     reduce using rule 69 (value -> FLOAT .)
    COMMA           reduce using rule 69 (value -> FLOAT .)
    DIVREAL         reduce using rule 69 (value -> FLOAT .)
    GA              reduce using rule 69 (value -> FLOAT .)
    EQUAL           reduce using rule 69 (value -> FLOAT .)
    NOT             reduce using rule 69 (value -> FLOAT .)
    NOT2            reduce using rule 69 (value -> FLOAT .)
    LESS            reduce using rule 69 (value -> FLOAT .)
    LESS_EQUAL      reduce using rule 69 (value -> FLOAT .)
    GREATER         reduce using rule 69 (value -> FLOAT .)
    GREATER_EQUAL   reduce using rule 69 (value -> FLOAT .)
    TO              reduce using rule 69 (value -> FLOAT .)
    DE              reduce using rule 69 (value -> FLOAT .)
    KARA            reduce using rule 69 (value -> FLOAT .)
    MADE            reduce using rule 69 (value -> FLOAT .)
    KO              reduce using rule 69 (value -> FLOAT .)
    R_C_BRACKET     reduce using rule 69 (value -> FLOAT .)


state 21

    (71) value -> STRING .

    WO              reduce using rule 71 (value -> STRING .)
    PLUS            reduce using rule 71 (value -> STRING .)
    MINUS           reduce using rule 71 (value -> STRING .)
    MULTI           reduce using rule 71 (value -> STRING .)
    ASTERISK        reduce using rule 71 (value -> STRING .)
    DIVID           reduce using rule 71 (value -> STRING .)
    NO              reduce using rule 71 (value -> STRING .)
    RSHIFT          reduce using rule 71 (value -> STRING .)
    LSHIFT          reduce using rule 71 (value -> STRING .)
    CONJUNCT        reduce using rule 71 (value -> STRING .)
    LOGICSUM        reduce using rule 71 (value -> STRING .)
    R_PAREN         reduce using rule 71 (value -> STRING .)
    $end            reduce using rule 71 (value -> STRING .)
    R_S_BRACKET     reduce using rule 71 (value -> STRING .)
    COMMA           reduce using rule 71 (value -> STRING .)
    DIVREAL         reduce using rule 71 (value -> STRING .)
    GA              reduce using rule 71 (value -> STRING .)
    EQUAL           reduce using rule 71 (value -> STRING .)
    NOT             reduce using rule 71 (value -> STRING .)
    NOT2            reduce using rule 71 (value -> STRING .)
    LESS            reduce using rule 71 (value -> STRING .)
    LESS_EQUAL      reduce using rule 71 (value -> STRING .)
    GREATER         reduce using rule 71 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 71 (value -> STRING .)
    TO              reduce using rule 71 (value -> STRING .)
    DE              reduce using rule 71 (value -> STRING .)
    KARA            reduce using rule 71 (value -> STRING .)
    MADE            reduce using rule 71 (value -> STRING .)
    KO              reduce using rule 71 (value -> STRING .)
    R_C_BRACKET     reduce using rule 71 (value -> STRING .)


state 22

    (2) statement -> TYPE COLON . decl_names
    (6) statement -> TYPE COLON . NAME ASSIGN value
    (37) statement -> TYPE COLON . NAME ASSIGN NAME L_PAREN args R_PAREN
    (3) decl_names -> . NAME decl_names_m

    NAME            shift and go to state 53

    decl_names                     shift and go to state 52

state 23

    (8) statement -> TYPE NO . ARRAY COLON NAME ASSIGN init_array
    (38) statement -> TYPE NO . ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    ARRAY           shift and go to state 54


state 24

    (16) statement -> TYPE ARRAY . NO ARRAY COLON NAME ASSIGN init_array2d

    NO              shift and go to state 55


state 25

    (7) statement -> NAME ASSIGN . value
    (36) statement -> NAME ASSIGN . NAME L_PAREN args R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    NAME            shift and go to state 56
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 57

state 26

    (14) statement -> NAME L_S_BRACKET . value R_S_BRACKET ASSIGN value
    (72) value -> NAME L_S_BRACKET . value R_S_BRACKET
    (73) value -> NAME L_S_BRACKET . value R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET . value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET . value R_S_BRACKET NO ARR_LEN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 58

state 27

    (15) statement -> NAME NO . END NI value WO ADD
    (39) statement -> NAME NO . END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (75) value -> NAME NO . ARR_LEN

    END             shift and go to state 59
    ARR_LEN         shift and go to state 60


state 28

    (35) statement -> NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 61
    value                          shift and go to state 62

state 29

    (21) statement -> value WO . OUT

    OUT             shift and go to state 63


state 30

    (79) value -> value PLUS . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 64

state 31

    (80) value -> value MINUS . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 65

state 32

    (81) value -> value MULTI . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 66

state 33

    (82) value -> value ASTERISK . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 67

state 34

    (83) value -> value DIVID . value division_tail
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 68

state 35

    (88) value -> value NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE

    DECIMAL_P       shift and go to state 69


state 36

    (90) value -> value RSHIFT . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 70

state 37

    (91) value -> value LSHIFT . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 71

state 38

    (92) value -> value CONJUNCT . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 72

state 39

    (93) value -> value LOGICSUM . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 73

state 40

    (17) statement -> GLOBAL COLON . TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d

    TYPE            shift and go to state 74


state 41

    (28) statement -> CIRCLE NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 75


state 42

    (29) statement -> CIRCLE TYPE . COLON NAME L_PAREN params R_PAREN
    (30) statement -> CIRCLE TYPE . NO ARRAY COLON NAME L_PAREN params R_PAREN

    COLON           shift and go to state 76
    NO              shift and go to state 77


state 43

    (77) value -> L_PAREN value . R_PAREN
    (78) value -> L_PAREN value . R_PAREN NO RESULT
    (89) value -> L_PAREN value . R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    R_PAREN         shift and go to state 78
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 44

    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    R_PAREN         reduce using rule 70 (value -> NAME .)
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    $end            reduce using rule 70 (value -> NAME .)
    WO              reduce using rule 70 (value -> NAME .)
    R_S_BRACKET     reduce using rule 70 (value -> NAME .)
    COMMA           reduce using rule 70 (value -> NAME .)
    DIVREAL         reduce using rule 70 (value -> NAME .)
    GA              reduce using rule 70 (value -> NAME .)
    EQUAL           reduce using rule 70 (value -> NAME .)
    NOT             reduce using rule 70 (value -> NAME .)
    NOT2            reduce using rule 70 (value -> NAME .)
    LESS            reduce using rule 70 (value -> NAME .)
    LESS_EQUAL      reduce using rule 70 (value -> NAME .)
    GREATER         reduce using rule 70 (value -> NAME .)
    GREATER_EQUAL   reduce using rule 70 (value -> NAME .)
    TO              reduce using rule 70 (value -> NAME .)
    DE              reduce using rule 70 (value -> NAME .)
    KARA            reduce using rule 70 (value -> NAME .)
    MADE            reduce using rule 70 (value -> NAME .)
    KO              reduce using rule 70 (value -> NAME .)
    R_C_BRACKET     reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 79
    NO              shift and go to state 80

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 45

    (42) statement -> RETURN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    $end            reduce using rule 42 (statement -> RETURN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 46

    (43) statement -> IF L_PAREN . conditional R_PAREN
    (47) conditional -> . value sign value
    (57) conditional -> . value GA value TO HITOSHII
    (58) conditional -> . value GA value TO NOTHITOSHII
    (59) conditional -> . value GA value DE DIVISIBLE
    (60) conditional -> . value GA value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    conditional                    shift and go to state 81
    value                          shift and go to state 82

state 47

    (44) statement -> ELSEIF L_PAREN . conditional R_PAREN
    (47) conditional -> . value sign value
    (57) conditional -> . value GA value TO HITOSHII
    (58) conditional -> . value GA value TO NOTHITOSHII
    (59) conditional -> . value GA value DE DIVISIBLE
    (60) conditional -> . value GA value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    conditional                    shift and go to state 83
    value                          shift and go to state 82

state 48

    (61) statement -> FOR L_PAREN . NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN

    NAME            shift and go to state 84


state 49

    (65) statement -> WHILE L_PAREN . conditional R_PAREN
    (47) conditional -> . value sign value
    (57) conditional -> . value GA value TO HITOSHII
    (58) conditional -> . value GA value TO NOTHITOSHII
    (59) conditional -> . value GA value DE DIVISIBLE
    (60) conditional -> . value GA value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    conditional                    shift and go to state 85
    value                          shift and go to state 82

state 50

    (40) value -> POW L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 86
    value                          shift and go to state 62

state 51

    (68) value -> MINUS value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              reduce using rule 68 (value -> MINUS value .)
    PLUS            reduce using rule 68 (value -> MINUS value .)
    MINUS           reduce using rule 68 (value -> MINUS value .)
    MULTI           reduce using rule 68 (value -> MINUS value .)
    ASTERISK        reduce using rule 68 (value -> MINUS value .)
    DIVID           reduce using rule 68 (value -> MINUS value .)
    NO              reduce using rule 68 (value -> MINUS value .)
    RSHIFT          reduce using rule 68 (value -> MINUS value .)
    LSHIFT          reduce using rule 68 (value -> MINUS value .)
    CONJUNCT        reduce using rule 68 (value -> MINUS value .)
    LOGICSUM        reduce using rule 68 (value -> MINUS value .)
    R_PAREN         reduce using rule 68 (value -> MINUS value .)
    $end            reduce using rule 68 (value -> MINUS value .)
    R_S_BRACKET     reduce using rule 68 (value -> MINUS value .)
    COMMA           reduce using rule 68 (value -> MINUS value .)
    DIVREAL         reduce using rule 68 (value -> MINUS value .)
    GA              reduce using rule 68 (value -> MINUS value .)
    EQUAL           reduce using rule 68 (value -> MINUS value .)
    NOT             reduce using rule 68 (value -> MINUS value .)
    NOT2            reduce using rule 68 (value -> MINUS value .)
    LESS            reduce using rule 68 (value -> MINUS value .)
    LESS_EQUAL      reduce using rule 68 (value -> MINUS value .)
    GREATER         reduce using rule 68 (value -> MINUS value .)
    GREATER_EQUAL   reduce using rule 68 (value -> MINUS value .)
    TO              reduce using rule 68 (value -> MINUS value .)
    DE              reduce using rule 68 (value -> MINUS value .)
    KARA            reduce using rule 68 (value -> MINUS value .)
    MADE            reduce using rule 68 (value -> MINUS value .)
    KO              reduce using rule 68 (value -> MINUS value .)
    R_C_BRACKET     reduce using rule 68 (value -> MINUS value .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! MULTI           [ shift and go to state 32 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! DIVID           [ shift and go to state 34 ]
  ! NO              [ shift and go to state 35 ]
  ! RSHIFT          [ shift and go to state 36 ]
  ! LSHIFT          [ shift and go to state 37 ]
  ! CONJUNCT        [ shift and go to state 38 ]
  ! LOGICSUM        [ shift and go to state 39 ]


state 52

    (2) statement -> TYPE COLON decl_names .

    $end            reduce using rule 2 (statement -> TYPE COLON decl_names .)


state 53

    (6) statement -> TYPE COLON NAME . ASSIGN value
    (37) statement -> TYPE COLON NAME . ASSIGN NAME L_PAREN args R_PAREN
    (3) decl_names -> NAME . decl_names_m
    (4) decl_names_m -> . COMMA NAME decl_names_m
    (5) decl_names_m -> .

    ASSIGN          shift and go to state 87
    COMMA           shift and go to state 89
    $end            reduce using rule 5 (decl_names_m -> .)

    decl_names_m                   shift and go to state 88

state 54

    (8) statement -> TYPE NO ARRAY . COLON NAME ASSIGN init_array
    (38) statement -> TYPE NO ARRAY . COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    COLON           shift and go to state 90


state 55

    (16) statement -> TYPE ARRAY NO . ARRAY COLON NAME ASSIGN init_array2d

    ARRAY           shift and go to state 91


state 56

    (36) statement -> NAME ASSIGN NAME . L_PAREN args R_PAREN
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 92
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    $end            reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 79
    NO              shift and go to state 80

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 57

    (7) statement -> NAME ASSIGN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    $end            reduce using rule 7 (statement -> NAME ASSIGN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 58

    (14) statement -> NAME L_S_BRACKET value . R_S_BRACKET ASSIGN value
    (72) value -> NAME L_S_BRACKET value . R_S_BRACKET
    (73) value -> NAME L_S_BRACKET value . R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET value . R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value . R_S_BRACKET NO ARR_LEN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    R_S_BRACKET     shift and go to state 93
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 59

    (15) statement -> NAME NO END . NI value WO ADD
    (39) statement -> NAME NO END . NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD

    NI              shift and go to state 94


state 60

    (75) value -> NAME NO ARR_LEN .

    WO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    PLUS            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    MINUS           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    MULTI           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    ASTERISK        reduce using rule 75 (value -> NAME NO ARR_LEN .)
    DIVID           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    NO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    RSHIFT          reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LSHIFT          reduce using rule 75 (value -> NAME NO ARR_LEN .)
    CONJUNCT        reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LOGICSUM        reduce using rule 75 (value -> NAME NO ARR_LEN .)
    R_PAREN         reduce using rule 75 (value -> NAME NO ARR_LEN .)
    $end            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    R_S_BRACKET     reduce using rule 75 (value -> NAME NO ARR_LEN .)
    COMMA           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    DIVREAL         reduce using rule 75 (value -> NAME NO ARR_LEN .)
    GA              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    EQUAL           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    NOT             reduce using rule 75 (value -> NAME NO ARR_LEN .)
    NOT2            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LESS            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LESS_EQUAL      reduce using rule 75 (value -> NAME NO ARR_LEN .)
    GREATER         reduce using rule 75 (value -> NAME NO ARR_LEN .)
    GREATER_EQUAL   reduce using rule 75 (value -> NAME NO ARR_LEN .)
    TO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    DE              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    KARA            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    MADE            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    KO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    R_C_BRACKET     reduce using rule 75 (value -> NAME NO ARR_LEN .)


state 61

    (35) statement -> NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 95


state 62

    (32) args -> value . args_m
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value
    (33) args_m -> . COMMA value args_m
    (34) args_m -> .

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39
    COMMA           shift and go to state 97
    R_PAREN         reduce using rule 34 (args_m -> .)

    args_m                         shift and go to state 96

state 63

    (21) statement -> value WO OUT .

    $end            reduce using rule 21 (statement -> value WO OUT .)


state 64

    (79) value -> value PLUS value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              reduce using rule 79 (value -> value PLUS value .)
    PLUS            reduce using rule 79 (value -> value PLUS value .)
    MINUS           reduce using rule 79 (value -> value PLUS value .)
    ASTERISK        reduce using rule 79 (value -> value PLUS value .)
    NO              reduce using rule 79 (value -> value PLUS value .)
    RSHIFT          reduce using rule 79 (value -> value PLUS value .)
    LSHIFT          reduce using rule 79 (value -> value PLUS value .)
    CONJUNCT        reduce using rule 79 (value -> value PLUS value .)
    LOGICSUM        reduce using rule 79 (value -> value PLUS value .)
    R_PAREN         reduce using rule 79 (value -> value PLUS value .)
    $end            reduce using rule 79 (value -> value PLUS value .)
    R_S_BRACKET     reduce using rule 79 (value -> value PLUS value .)
    COMMA           reduce using rule 79 (value -> value PLUS value .)
    DIVREAL         reduce using rule 79 (value -> value PLUS value .)
    GA              reduce using rule 79 (value -> value PLUS value .)
    EQUAL           reduce using rule 79 (value -> value PLUS value .)
    NOT             reduce using rule 79 (value -> value PLUS value .)
    NOT2            reduce using rule 79 (value -> value PLUS value .)
    LESS            reduce using rule 79 (value -> value PLUS value .)
    LESS_EQUAL      reduce using rule 79 (value -> value PLUS value .)
    GREATER         reduce using rule 79 (value -> value PLUS value .)
    GREATER_EQUAL   reduce using rule 79 (value -> value PLUS value .)
    TO              reduce using rule 79 (value -> value PLUS value .)
    DE              reduce using rule 79 (value -> value PLUS value .)
    KARA            reduce using rule 79 (value -> value PLUS value .)
    MADE            reduce using rule 79 (value -> value PLUS value .)
    KO              reduce using rule 79 (value -> value PLUS value .)
    R_C_BRACKET     reduce using rule 79 (value -> value PLUS value .)
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! MULTI           [ reduce using rule 79 (value -> value PLUS value .) ]
  ! DIVID           [ reduce using rule 79 (value -> value PLUS value .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! NO              [ shift and go to state 35 ]
  ! RSHIFT          [ shift and go to state 36 ]
  ! LSHIFT          [ shift and go to state 37 ]
  ! CONJUNCT        [ shift and go to state 38 ]
  ! LOGICSUM        [ shift and go to state 39 ]


state 65

    (80) value -> value MINUS value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              reduce using rule 80 (value -> value MINUS value .)
    PLUS            reduce using rule 80 (value -> value MINUS value .)
    MINUS           reduce using rule 80 (value -> value MINUS value .)
    ASTERISK        reduce using rule 80 (value -> value MINUS value .)
    NO              reduce using rule 80 (value -> value MINUS value .)
    RSHIFT          reduce using rule 80 (value -> value MINUS value .)
    LSHIFT          reduce using rule 80 (value -> value MINUS value .)
    CONJUNCT        reduce using rule 80 (value -> value MINUS value .)
    LOGICSUM        reduce using rule 80 (value -> value MINUS value .)
    R_PAREN         reduce using rule 80 (value -> value MINUS value .)
    $end            reduce using rule 80 (value -> value MINUS value .)
    R_S_BRACKET     reduce using rule 80 (value -> value MINUS value .)
    COMMA           reduce using rule 80 (value -> value MINUS value .)
    DIVREAL         reduce using rule 80 (value -> value MINUS value .)
    GA              reduce using rule 80 (value -> value MINUS value .)
    EQUAL           reduce using rule 80 (value -> value MINUS value .)
    NOT             reduce using rule 80 (value -> value MINUS value .)
    NOT2            reduce using rule 80 (value -> value MINUS value .)
    LESS            reduce using rule 80 (value -> value MINUS value .)
    LESS_EQUAL      reduce using rule 80 (value -> value MINUS value .)
    GREATER         reduce using rule 80 (value -> value MINUS value .)
    GREATER_EQUAL   reduce using rule 80 (value -> value MINUS value .)
    TO              reduce using rule 80 (value -> value MINUS value .)
    DE              reduce using rule 80 (value -> value MINUS value .)
    KARA            reduce using rule 80 (value -> value MINUS value .)
    MADE            reduce using rule 80 (value -> value MINUS value .)
    KO              reduce using rule 80 (value -> value MINUS value .)
    R_C_BRACKET     reduce using rule 80 (value -> value MINUS value .)
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! MULTI           [ reduce using rule 80 (value -> value MINUS value .) ]
  ! DIVID           [ reduce using rule 80 (value -> value MINUS value .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! NO              [ shift and go to state 35 ]
  ! RSHIFT          [ shift and go to state 36 ]
  ! LSHIFT          [ shift and go to state 37 ]
  ! CONJUNCT        [ shift and go to state 38 ]
  ! LOGICSUM        [ shift and go to state 39 ]


state 66

    (81) value -> value MULTI value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              reduce using rule 81 (value -> value MULTI value .)
    PLUS            reduce using rule 81 (value -> value MULTI value .)
    MINUS           reduce using rule 81 (value -> value MULTI value .)
    MULTI           reduce using rule 81 (value -> value MULTI value .)
    ASTERISK        reduce using rule 81 (value -> value MULTI value .)
    DIVID           reduce using rule 81 (value -> value MULTI value .)
    NO              reduce using rule 81 (value -> value MULTI value .)
    RSHIFT          reduce using rule 81 (value -> value MULTI value .)
    LSHIFT          reduce using rule 81 (value -> value MULTI value .)
    CONJUNCT        reduce using rule 81 (value -> value MULTI value .)
    LOGICSUM        reduce using rule 81 (value -> value MULTI value .)
    R_PAREN         reduce using rule 81 (value -> value MULTI value .)
    $end            reduce using rule 81 (value -> value MULTI value .)
    R_S_BRACKET     reduce using rule 81 (value -> value MULTI value .)
    COMMA           reduce using rule 81 (value -> value MULTI value .)
    DIVREAL         reduce using rule 81 (value -> value MULTI value .)
    GA              reduce using rule 81 (value -> value MULTI value .)
    EQUAL           reduce using rule 81 (value -> value MULTI value .)
    NOT             reduce using rule 81 (value -> value MULTI value .)
    NOT2            reduce using rule 81 (value -> value MULTI value .)
    LESS            reduce using rule 81 (value -> value MULTI value .)
    LESS_EQUAL      reduce using rule 81 (value -> value MULTI value .)
    GREATER         reduce using rule 81 (value -> value MULTI value .)
    GREATER_EQUAL   reduce using rule 81 (value -> value MULTI value .)
    TO              reduce using rule 81 (value -> value MULTI value .)
    DE              reduce using rule 81 (value -> value MULTI value .)
    KARA            reduce using rule 81 (value -> value MULTI value .)
    MADE            reduce using rule 81 (value -> value MULTI value .)
    KO              reduce using rule 81 (value -> value MULTI value .)
    R_C_BRACKET     reduce using rule 81 (value -> value MULTI value .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! MULTI           [ shift and go to state 32 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! DIVID           [ shift and go to state 34 ]
  ! NO              [ shift and go to state 35 ]
  ! RSHIFT          [ shift and go to state 36 ]
  ! LSHIFT          [ shift and go to state 37 ]
  ! CONJUNCT        [ shift and go to state 38 ]
  ! LOGICSUM        [ shift and go to state 39 ]


state 67

    (82) value -> value ASTERISK value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
    WO              reduce using rule 82 (value -> value ASTERISK value .)
    R_PAREN         reduce using rule 82 (value -> value ASTERISK value .)
    $end            reduce using rule 82 (value -> value ASTERISK value .)
    R_S_BRACKET     reduce using rule 82 (value -> value ASTERISK value .)
    COMMA           reduce using rule 82 (value -> value ASTERISK value .)
    DIVREAL         reduce using rule 82 (value -> value ASTERISK value .)
    GA              reduce using rule 82 (value -> value ASTERISK value .)
    EQUAL           reduce using rule 82 (value -> value ASTERISK value .)
    NOT             reduce using rule 82 (value -> value ASTERISK value .)
    NOT2            reduce using rule 82 (value -> value ASTERISK value .)
    LESS            reduce using rule 82 (value -> value ASTERISK value .)
    LESS_EQUAL      reduce using rule 82 (value -> value ASTERISK value .)
    GREATER         reduce using rule 82 (value -> value ASTERISK value .)
    GREATER_EQUAL   reduce using rule 82 (value -> value ASTERISK value .)
    TO              reduce using rule 82 (value -> value ASTERISK value .)
    DE              reduce using rule 82 (value -> value ASTERISK value .)
    KARA            reduce using rule 82 (value -> value ASTERISK value .)
    MADE            reduce using rule 82 (value -> value ASTERISK value .)
    KO              reduce using rule 82 (value -> value ASTERISK value .)
    R_C_BRACKET     reduce using rule 82 (value -> value ASTERISK value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39

  ! PLUS            [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! MINUS           [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! MULTI           [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! ASTERISK        [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! DIVID           [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! NO              [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! RSHIFT          [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! LSHIFT          [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! CONJUNCT        [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! LOGICSUM        [ reduce using rule 82 (value -> value ASTERISK value .) ]


state 68

    (83) value -> value DIVID value . division_tail
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value
    (84) division_tail -> . NO SHOW
    (85) division_tail -> . NO REMAINDER
    (86) division_tail -> . DIVREAL
    (87) division_tail -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
  ! shift/reduce conflict for DIVREAL resolved as shift
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 99
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39
    DIVREAL         shift and go to state 100
    WO              reduce using rule 87 (division_tail -> .)
    R_PAREN         reduce using rule 87 (division_tail -> .)
    $end            reduce using rule 87 (division_tail -> .)
    R_S_BRACKET     reduce using rule 87 (division_tail -> .)
    COMMA           reduce using rule 87 (division_tail -> .)
    GA              reduce using rule 87 (division_tail -> .)
    EQUAL           reduce using rule 87 (division_tail -> .)
    NOT             reduce using rule 87 (division_tail -> .)
    NOT2            reduce using rule 87 (division_tail -> .)
    LESS            reduce using rule 87 (division_tail -> .)
    LESS_EQUAL      reduce using rule 87 (division_tail -> .)
    GREATER         reduce using rule 87 (division_tail -> .)
    GREATER_EQUAL   reduce using rule 87 (division_tail -> .)
    TO              reduce using rule 87 (division_tail -> .)
    DE              reduce using rule 87 (division_tail -> .)
    KARA            reduce using rule 87 (division_tail -> .)
    MADE            reduce using rule 87 (division_tail -> .)
    KO              reduce using rule 87 (division_tail -> .)
    R_C_BRACKET     reduce using rule 87 (division_tail -> .)

  ! PLUS            [ reduce using rule 87 (division_tail -> .) ]
  ! MINUS           [ reduce using rule 87 (division_tail -> .) ]
  ! MULTI           [ reduce using rule 87 (division_tail -> .) ]
  ! ASTERISK        [ reduce using rule 87 (division_tail -> .) ]
  ! DIVID           [ reduce using rule 87 (division_tail -> .) ]
  ! NO              [ reduce using rule 87 (division_tail -> .) ]
  ! RSHIFT          [ reduce using rule 87 (division_tail -> .) ]
  ! LSHIFT          [ reduce using rule 87 (division_tail -> .) ]
  ! CONJUNCT        [ reduce using rule 87 (division_tail -> .) ]
  ! LOGICSUM        [ reduce using rule 87 (division_tail -> .) ]
  ! DIVREAL         [ reduce using rule 87 (division_tail -> .) ]

    division_tail                  shift and go to state 98

state 69

    (88) value -> value NO DECIMAL_P . BELOW WO ROUNDED_UP VALUE

    BELOW           shift and go to state 101


state 70

    (90) value -> value RSHIFT value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              reduce using rule 90 (value -> value RSHIFT value .)
    ASTERISK        reduce using rule 90 (value -> value RSHIFT value .)
    NO              reduce using rule 90 (value -> value RSHIFT value .)
    RSHIFT          reduce using rule 90 (value -> value RSHIFT value .)
    LSHIFT          reduce using rule 90 (value -> value RSHIFT value .)
    CONJUNCT        reduce using rule 90 (value -> value RSHIFT value .)
    LOGICSUM        reduce using rule 90 (value -> value RSHIFT value .)
    R_PAREN         reduce using rule 90 (value -> value RSHIFT value .)
    $end            reduce using rule 90 (value -> value RSHIFT value .)
    R_S_BRACKET     reduce using rule 90 (value -> value RSHIFT value .)
    COMMA           reduce using rule 90 (value -> value RSHIFT value .)
    DIVREAL         reduce using rule 90 (value -> value RSHIFT value .)
    GA              reduce using rule 90 (value -> value RSHIFT value .)
    EQUAL           reduce using rule 90 (value -> value RSHIFT value .)
    NOT             reduce using rule 90 (value -> value RSHIFT value .)
    NOT2            reduce using rule 90 (value -> value RSHIFT value .)
    LESS            reduce using rule 90 (value -> value RSHIFT value .)
    LESS_EQUAL      reduce using rule 90 (value -> value RSHIFT value .)
    GREATER         reduce using rule 90 (value -> value RSHIFT value .)
    GREATER_EQUAL   reduce using rule 90 (value -> value RSHIFT value .)
    TO              reduce using rule 90 (value -> value RSHIFT value .)
    DE              reduce using rule 90 (value -> value RSHIFT value .)
    KARA            reduce using rule 90 (value -> value RSHIFT value .)
    MADE            reduce using rule 90 (value -> value RSHIFT value .)
    KO              reduce using rule 90 (value -> value RSHIFT value .)
    R_C_BRACKET     reduce using rule 90 (value -> value RSHIFT value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! PLUS            [ reduce using rule 90 (value -> value RSHIFT value .) ]
  ! MINUS           [ reduce using rule 90 (value -> value RSHIFT value .) ]
  ! MULTI           [ reduce using rule 90 (value -> value RSHIFT value .) ]
  ! DIVID           [ reduce using rule 90 (value -> value RSHIFT value .) ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! NO              [ shift and go to state 35 ]
  ! RSHIFT          [ shift and go to state 36 ]
  ! LSHIFT          [ shift and go to state 37 ]
  ! CONJUNCT        [ shift and go to state 38 ]
  ! LOGICSUM        [ shift and go to state 39 ]


state 71

    (91) value -> value LSHIFT value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              reduce using rule 91 (value -> value LSHIFT value .)
    ASTERISK        reduce using rule 91 (value -> value LSHIFT value .)
    NO              reduce using rule 91 (value -> value LSHIFT value .)
    RSHIFT          reduce using rule 91 (value -> value LSHIFT value .)
    LSHIFT          reduce using rule 91 (value -> value LSHIFT value .)
    CONJUNCT        reduce using rule 91 (value -> value LSHIFT value .)
    LOGICSUM        reduce using rule 91 (value -> value LSHIFT value .)
    R_PAREN         reduce using rule 91 (value -> value LSHIFT value .)
    $end            reduce using rule 91 (value -> value LSHIFT value .)
    R_S_BRACKET     reduce using rule 91 (value -> value LSHIFT value .)
    COMMA           reduce using rule 91 (value -> value LSHIFT value .)
    DIVREAL         reduce using rule 91 (value -> value LSHIFT value .)
    GA              reduce using rule 91 (value -> value LSHIFT value .)
    EQUAL           reduce using rule 91 (value -> value LSHIFT value .)
    NOT             reduce using rule 91 (value -> value LSHIFT value .)
    NOT2            reduce using rule 91 (value -> value LSHIFT value .)
    LESS            reduce using rule 91 (value -> value LSHIFT value .)
    LESS_EQUAL      reduce using rule 91 (value -> value LSHIFT value .)
    GREATER         reduce using rule 91 (value -> value LSHIFT value .)
    GREATER_EQUAL   reduce using rule 91 (value -> value LSHIFT value .)
    TO              reduce using rule 91 (value -> value LSHIFT value .)
    DE              reduce using rule 91 (value -> value LSHIFT value .)
    KARA            reduce using rule 91 (value -> value LSHIFT value .)
    MADE            reduce using rule 91 (value -> value LSHIFT value .)
    KO              reduce using rule 91 (value -> value LSHIFT value .)
    R_C_BRACKET     reduce using rule 91 (value -> value LSHIFT value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! PLUS            [ reduce using rule 91 (value -> value LSHIFT value .) ]
  ! MINUS           [ reduce using rule 91 (value -> value LSHIFT value .) ]
  ! MULTI           [ reduce using rule 91 (value -> value LSHIFT value .) ]
  ! DIVID           [ reduce using rule 91 (value -> value LSHIFT value .) ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! NO              [ shift and go to state 35 ]
  ! RSHIFT          [ shift and go to state 36 ]
  ! LSHIFT          [ shift and go to state 37 ]
  ! CONJUNCT        [ shift and go to state 38 ]
  ! LOGICSUM        [ shift and go to state 39 ]


state 72

    (92) value -> value CONJUNCT value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
    WO              reduce using rule 92 (value -> value CONJUNCT value .)
    R_PAREN         reduce using rule 92 (value -> value CONJUNCT value .)
    $end            reduce using rule 92 (value -> value CONJUNCT value .)
    R_S_BRACKET     reduce using rule 92 (value -> value CONJUNCT value .)
    COMMA           reduce using rule 92 (value -> value CONJUNCT value .)
    DIVREAL         reduce using rule 92 (value -> value CONJUNCT value .)
    GA              reduce using rule 92 (value -> value CONJUNCT value .)
    EQUAL           reduce using rule 92 (value -> value CONJUNCT value .)
    NOT             reduce using rule 92 (value -> value CONJUNCT value .)
    NOT2            reduce using rule 92 (value -> value CONJUNCT value .)
    LESS            reduce using rule 92 (value -> value CONJUNCT value .)
    LESS_EQUAL      reduce using rule 92 (value -> value CONJUNCT value .)
    GREATER         reduce using rule 92 (value -> value CONJUNCT value .)
    GREATER_EQUAL   reduce using rule 92 (value -> value CONJUNCT value .)
    TO              reduce using rule 92 (value -> value CONJUNCT value .)
    DE              reduce using rule 92 (value -> value CONJUNCT value .)
    KARA            reduce using rule 92 (value -> value CONJUNCT value .)
    MADE            reduce using rule 92 (value -> value CONJUNCT value .)
    KO              reduce using rule 92 (value -> value CONJUNCT value .)
    R_C_BRACKET     reduce using rule 92 (value -> value CONJUNCT value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39

  ! PLUS            [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! MINUS           [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! MULTI           [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! ASTERISK        [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! DIVID           [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! NO              [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! RSHIFT          [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! LSHIFT          [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! CONJUNCT        [ reduce using rule 92 (value -> value CONJUNCT value .) ]
  ! LOGICSUM        [ reduce using rule 92 (value -> value CONJUNCT value .) ]


state 73

    (93) value -> value LOGICSUM value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
    WO              reduce using rule 93 (value -> value LOGICSUM value .)
    R_PAREN         reduce using rule 93 (value -> value LOGICSUM value .)
    $end            reduce using rule 93 (value -> value LOGICSUM value .)
    R_S_BRACKET     reduce using rule 93 (value -> value LOGICSUM value .)
    COMMA           reduce using rule 93 (value -> value LOGICSUM value .)
    DIVREAL         reduce using rule 93 (value -> value LOGICSUM value .)
    GA              reduce using rule 93 (value -> value LOGICSUM value .)
    EQUAL           reduce using rule 93 (value -> value LOGICSUM value .)
    NOT             reduce using rule 93 (value -> value LOGICSUM value .)
    NOT2            reduce using rule 93 (value -> value LOGICSUM value .)
    LESS            reduce using rule 93 (value -> value LOGICSUM value .)
    LESS_EQUAL      reduce using rule 93 (value -> value LOGICSUM value .)
    GREATER         reduce using rule 93 (value -> value LOGICSUM value .)
    GREATER_EQUAL   reduce using rule 93 (value -> value LOGICSUM value .)
    TO              reduce using rule 93 (value -> value LOGICSUM value .)
    DE              reduce using rule 93 (value -> value LOGICSUM value .)
    KARA            reduce using rule 93 (value -> value LOGICSUM value .)
    MADE            reduce using rule 93 (value -> value LOGICSUM value .)
    KO              reduce using rule 93 (value -> value LOGICSUM value .)
    R_C_BRACKET     reduce using rule 93 (value -> value LOGICSUM value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39

  ! PLUS            [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! MINUS           [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! MULTI           [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! ASTERISK        [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! DIVID           [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! NO              [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! RSHIFT          [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! LSHIFT          [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! CONJUNCT        [ reduce using rule 93 (value -> value LOGICSUM value .) ]
  ! LOGICSUM        [ reduce using rule 93 (value -> value LOGICSUM value .) ]


state 74

    (17) statement -> GLOBAL COLON TYPE . ARRAY NO ARRAY COLON NAME ASSIGN init_array2d

    ARRAY           shift and go to state 102


state 75

    (28) statement -> CIRCLE NAME L_PAREN . params R_PAREN
    (22) params -> .
    (23) params -> . TYPE COLON NAME params_m
    (24) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 22 (params -> .)
    TYPE            shift and go to state 104

    params                         shift and go to state 103

state 76

    (29) statement -> CIRCLE TYPE COLON . NAME L_PAREN params R_PAREN

    NAME            shift and go to state 105


state 77

    (30) statement -> CIRCLE TYPE NO . ARRAY COLON NAME L_PAREN params R_PAREN

    ARRAY           shift and go to state 106


state 78

    (77) value -> L_PAREN value R_PAREN .
    (78) value -> L_PAREN value R_PAREN . NO RESULT
    (89) value -> L_PAREN value R_PAREN . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

  ! shift/reduce conflict for NO resolved as shift
    WO              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    PLUS            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    MINUS           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    MULTI           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    ASTERISK        reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    DIVID           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    RSHIFT          reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LSHIFT          reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    CONJUNCT        reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LOGICSUM        reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    R_PAREN         reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    $end            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    R_S_BRACKET     reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    COMMA           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    DIVREAL         reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    GA              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    EQUAL           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    NOT             reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    NOT2            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LESS            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LESS_EQUAL      reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    GREATER         reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    GREATER_EQUAL   reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    TO              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    DE              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    KARA            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    MADE            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    KO              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    R_C_BRACKET     reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    NO              shift and go to state 107

  ! NO              [ reduce using rule 77 (value -> L_PAREN value R_PAREN .) ]


state 79

    (72) value -> NAME L_S_BRACKET . value R_S_BRACKET
    (73) value -> NAME L_S_BRACKET . value R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET . value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET . value R_S_BRACKET NO ARR_LEN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 108

state 80

    (75) value -> NAME NO . ARR_LEN

    ARR_LEN         shift and go to state 60


state 81

    (43) statement -> IF L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 109


state 82

    (47) conditional -> value . sign value
    (57) conditional -> value . GA value TO HITOSHII
    (58) conditional -> value . GA value TO NOTHITOSHII
    (59) conditional -> value . GA value DE DIVISIBLE
    (60) conditional -> value . GA value TO value DE DIVISIBLE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value
    (48) sign -> . EQUAL
    (49) sign -> . NOT EQUAL
    (50) sign -> . NOT2
    (51) sign -> . LESS
    (52) sign -> . LESS EQUAL
    (53) sign -> . LESS_EQUAL
    (54) sign -> . GREATER
    (55) sign -> . GREATER EQUAL
    (56) sign -> . GREATER_EQUAL

    GA              shift and go to state 111
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39
    EQUAL           shift and go to state 112
    NOT             shift and go to state 113
    NOT2            shift and go to state 114
    LESS            shift and go to state 115
    LESS_EQUAL      shift and go to state 116
    GREATER         shift and go to state 117
    GREATER_EQUAL   shift and go to state 118

    sign                           shift and go to state 110

state 83

    (44) statement -> ELSEIF L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 119


state 84

    (61) statement -> FOR L_PAREN NAME . WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN

    WO              shift and go to state 120


state 85

    (65) statement -> WHILE L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 121


state 86

    (40) value -> POW L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 122


state 87

    (6) statement -> TYPE COLON NAME ASSIGN . value
    (37) statement -> TYPE COLON NAME ASSIGN . NAME L_PAREN args R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    NAME            shift and go to state 123
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 124

state 88

    (3) decl_names -> NAME decl_names_m .

    $end            reduce using rule 3 (decl_names -> NAME decl_names_m .)


state 89

    (4) decl_names_m -> COMMA . NAME decl_names_m

    NAME            shift and go to state 125


state 90

    (8) statement -> TYPE NO ARRAY COLON . NAME ASSIGN init_array
    (38) statement -> TYPE NO ARRAY COLON . NAME ASSIGN NAME L_PAREN args R_PAREN

    NAME            shift and go to state 126


state 91

    (16) statement -> TYPE ARRAY NO ARRAY . COLON NAME ASSIGN init_array2d

    COLON           shift and go to state 127


state 92

    (36) statement -> NAME ASSIGN NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 128
    value                          shift and go to state 62

state 93

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET . ASSIGN value
    (72) value -> NAME L_S_BRACKET value R_S_BRACKET .
    (73) value -> NAME L_S_BRACKET value R_S_BRACKET . NO VALUE
    (74) value -> NAME L_S_BRACKET value R_S_BRACKET . L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value R_S_BRACKET . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    ASSIGN          shift and go to state 130
    WO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    ASTERISK        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    RSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    CONJUNCT        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LOGICSUM        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NO              shift and go to state 131
    L_S_BRACKET     shift and go to state 129

  ! NO              [ reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .) ]


state 94

    (15) statement -> NAME NO END NI . value WO ADD
    (39) statement -> NAME NO END NI . NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    NAME            shift and go to state 132
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 133

state 95

    (35) statement -> NAME L_PAREN args R_PAREN .

    $end            reduce using rule 35 (statement -> NAME L_PAREN args R_PAREN .)


state 96

    (32) args -> value args_m .

    R_PAREN         reduce using rule 32 (args -> value args_m .)


state 97

    (33) args_m -> COMMA . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 134

state 98

    (83) value -> value DIVID value division_tail .

    WO              reduce using rule 83 (value -> value DIVID value division_tail .)
    PLUS            reduce using rule 83 (value -> value DIVID value division_tail .)
    MINUS           reduce using rule 83 (value -> value DIVID value division_tail .)
    MULTI           reduce using rule 83 (value -> value DIVID value division_tail .)
    ASTERISK        reduce using rule 83 (value -> value DIVID value division_tail .)
    DIVID           reduce using rule 83 (value -> value DIVID value division_tail .)
    NO              reduce using rule 83 (value -> value DIVID value division_tail .)
    RSHIFT          reduce using rule 83 (value -> value DIVID value division_tail .)
    LSHIFT          reduce using rule 83 (value -> value DIVID value division_tail .)
    CONJUNCT        reduce using rule 83 (value -> value DIVID value division_tail .)
    LOGICSUM        reduce using rule 83 (value -> value DIVID value division_tail .)
    R_PAREN         reduce using rule 83 (value -> value DIVID value division_tail .)
    $end            reduce using rule 83 (value -> value DIVID value division_tail .)
    R_S_BRACKET     reduce using rule 83 (value -> value DIVID value division_tail .)
    COMMA           reduce using rule 83 (value -> value DIVID value division_tail .)
    DIVREAL         reduce using rule 83 (value -> value DIVID value division_tail .)
    GA              reduce using rule 83 (value -> value DIVID value division_tail .)
    EQUAL           reduce using rule 83 (value -> value DIVID value division_tail .)
    NOT             reduce using rule 83 (value -> value DIVID value division_tail .)
    NOT2            reduce using rule 83 (value -> value DIVID value division_tail .)
    LESS            reduce using rule 83 (value -> value DIVID value division_tail .)
    LESS_EQUAL      reduce using rule 83 (value -> value DIVID value division_tail .)
    GREATER         reduce using rule 83 (value -> value DIVID value division_tail .)
    GREATER_EQUAL   reduce using rule 83 (value -> value DIVID value division_tail .)
    TO              reduce using rule 83 (value -> value DIVID value division_tail .)
    DE              reduce using rule 83 (value -> value DIVID value division_tail .)
    KARA            reduce using rule 83 (value -> value DIVID value division_tail .)
    MADE            reduce using rule 83 (value -> value DIVID value division_tail .)
    KO              reduce using rule 83 (value -> value DIVID value division_tail .)
    R_C_BRACKET     reduce using rule 83 (value -> value DIVID value division_tail .)


state 99

    (88) value -> value NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (84) division_tail -> NO . SHOW
    (85) division_tail -> NO . REMAINDER

    DECIMAL_P       shift and go to state 69
    SHOW            shift and go to state 135
    REMAINDER       shift and go to state 136


state 100

    (86) division_tail -> DIVREAL .

    WO              reduce using rule 86 (division_tail -> DIVREAL .)
    PLUS            reduce using rule 86 (division_tail -> DIVREAL .)
    MINUS           reduce using rule 86 (division_tail -> DIVREAL .)
    MULTI           reduce using rule 86 (division_tail -> DIVREAL .)
    ASTERISK        reduce using rule 86 (division_tail -> DIVREAL .)
    DIVID           reduce using rule 86 (division_tail -> DIVREAL .)
    NO              reduce using rule 86 (division_tail -> DIVREAL .)
    RSHIFT          reduce using rule 86 (division_tail -> DIVREAL .)
    LSHIFT          reduce using rule 86 (division_tail -> DIVREAL .)
    CONJUNCT        reduce using rule 86 (division_tail -> DIVREAL .)
    LOGICSUM        reduce using rule 86 (division_tail -> DIVREAL .)
    R_PAREN         reduce using rule 86 (division_tail -> DIVREAL .)
    $end            reduce using rule 86 (division_tail -> DIVREAL .)
    R_S_BRACKET     reduce using rule 86 (division_tail -> DIVREAL .)
    COMMA           reduce using rule 86 (division_tail -> DIVREAL .)
    DIVREAL         reduce using rule 86 (division_tail -> DIVREAL .)
    GA              reduce using rule 86 (division_tail -> DIVREAL .)
    EQUAL           reduce using rule 86 (division_tail -> DIVREAL .)
    NOT             reduce using rule 86 (division_tail -> DIVREAL .)
    NOT2            reduce using rule 86 (division_tail -> DIVREAL .)
    LESS            reduce using rule 86 (division_tail -> DIVREAL .)
    LESS_EQUAL      reduce using rule 86 (division_tail -> DIVREAL .)
    GREATER         reduce using rule 86 (division_tail -> DIVREAL .)
    GREATER_EQUAL   reduce using rule 86 (division_tail -> DIVREAL .)
    TO              reduce using rule 86 (division_tail -> DIVREAL .)
    DE              reduce using rule 86 (division_tail -> DIVREAL .)
    KARA            reduce using rule 86 (division_tail -> DIVREAL .)
    MADE            reduce using rule 86 (division_tail -> DIVREAL .)
    KO              reduce using rule 86 (division_tail -> DIVREAL .)
    R_C_BRACKET     reduce using rule 86 (division_tail -> DIVREAL .)


state 101

    (88) value -> value NO DECIMAL_P BELOW . WO ROUNDED_UP VALUE

    WO              shift and go to state 137


state 102

    (17) statement -> GLOBAL COLON TYPE ARRAY . NO ARRAY COLON NAME ASSIGN init_array2d

    NO              shift and go to state 138


state 103

    (28) statement -> CIRCLE NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 139


state 104

    (23) params -> TYPE . COLON NAME params_m
    (24) params -> TYPE . NO ARRAY COLON NAME params_m

    COLON           shift and go to state 140
    NO              shift and go to state 141


state 105

    (29) statement -> CIRCLE TYPE COLON NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 142


state 106

    (30) statement -> CIRCLE TYPE NO ARRAY . COLON NAME L_PAREN params R_PAREN

    COLON           shift and go to state 143


state 107

    (78) value -> L_PAREN value R_PAREN NO . RESULT
    (89) value -> L_PAREN value R_PAREN NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE

    RESULT          shift and go to state 144
    DECIMAL_P       shift and go to state 145


state 108

    (72) value -> NAME L_S_BRACKET value . R_S_BRACKET
    (73) value -> NAME L_S_BRACKET value . R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET value . R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value . R_S_BRACKET NO ARR_LEN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    R_S_BRACKET     shift and go to state 146
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 109

    (43) statement -> IF L_PAREN conditional R_PAREN .

    $end            reduce using rule 43 (statement -> IF L_PAREN conditional R_PAREN .)


state 110

    (47) conditional -> value sign . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 147

state 111

    (57) conditional -> value GA . value TO HITOSHII
    (58) conditional -> value GA . value TO NOTHITOSHII
    (59) conditional -> value GA . value DE DIVISIBLE
    (60) conditional -> value GA . value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 148

state 112

    (48) sign -> EQUAL .

    POW             reduce using rule 48 (sign -> EQUAL .)
    NUMBER          reduce using rule 48 (sign -> EQUAL .)
    MINUS           reduce using rule 48 (sign -> EQUAL .)
    FLOAT           reduce using rule 48 (sign -> EQUAL .)
    NAME            reduce using rule 48 (sign -> EQUAL .)
    STRING          reduce using rule 48 (sign -> EQUAL .)
    L_PAREN         reduce using rule 48 (sign -> EQUAL .)


state 113

    (49) sign -> NOT . EQUAL

    EQUAL           shift and go to state 149


state 114

    (50) sign -> NOT2 .

    POW             reduce using rule 50 (sign -> NOT2 .)
    NUMBER          reduce using rule 50 (sign -> NOT2 .)
    MINUS           reduce using rule 50 (sign -> NOT2 .)
    FLOAT           reduce using rule 50 (sign -> NOT2 .)
    NAME            reduce using rule 50 (sign -> NOT2 .)
    STRING          reduce using rule 50 (sign -> NOT2 .)
    L_PAREN         reduce using rule 50 (sign -> NOT2 .)


state 115

    (51) sign -> LESS .
    (52) sign -> LESS . EQUAL

    POW             reduce using rule 51 (sign -> LESS .)
    NUMBER          reduce using rule 51 (sign -> LESS .)
    MINUS           reduce using rule 51 (sign -> LESS .)
    FLOAT           reduce using rule 51 (sign -> LESS .)
    NAME            reduce using rule 51 (sign -> LESS .)
    STRING          reduce using rule 51 (sign -> LESS .)
    L_PAREN         reduce using rule 51 (sign -> LESS .)
    EQUAL           shift and go to state 150


state 116

    (53) sign -> LESS_EQUAL .

    POW             reduce using rule 53 (sign -> LESS_EQUAL .)
    NUMBER          reduce using rule 53 (sign -> LESS_EQUAL .)
    MINUS           reduce using rule 53 (sign -> LESS_EQUAL .)
    FLOAT           reduce using rule 53 (sign -> LESS_EQUAL .)
    NAME            reduce using rule 53 (sign -> LESS_EQUAL .)
    STRING          reduce using rule 53 (sign -> LESS_EQUAL .)
    L_PAREN         reduce using rule 53 (sign -> LESS_EQUAL .)


state 117

    (54) sign -> GREATER .
    (55) sign -> GREATER . EQUAL

    POW             reduce using rule 54 (sign -> GREATER .)
    NUMBER          reduce using rule 54 (sign -> GREATER .)
    MINUS           reduce using rule 54 (sign -> GREATER .)
    FLOAT           reduce using rule 54 (sign -> GREATER .)
    NAME            reduce using rule 54 (sign -> GREATER .)
    STRING          reduce using rule 54 (sign -> GREATER .)
    L_PAREN         reduce using rule 54 (sign -> GREATER .)
    EQUAL           shift and go to state 151


state 118

    (56) sign -> GREATER_EQUAL .

    POW             reduce using rule 56 (sign -> GREATER_EQUAL .)
    NUMBER          reduce using rule 56 (sign -> GREATER_EQUAL .)
    MINUS           reduce using rule 56 (sign -> GREATER_EQUAL .)
    FLOAT           reduce using rule 56 (sign -> GREATER_EQUAL .)
    NAME            reduce using rule 56 (sign -> GREATER_EQUAL .)
    STRING          reduce using rule 56 (sign -> GREATER_EQUAL .)
    L_PAREN         reduce using rule 56 (sign -> GREATER_EQUAL .)


state 119

    (44) statement -> ELSEIF L_PAREN conditional R_PAREN .

    $end            reduce using rule 44 (statement -> ELSEIF L_PAREN conditional R_PAREN .)


state 120

    (61) statement -> FOR L_PAREN NAME WO . value KARA value MADE NUMBER ZUTSU incdec R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 152

state 121

    (65) statement -> WHILE L_PAREN conditional R_PAREN .

    $end            reduce using rule 65 (statement -> WHILE L_PAREN conditional R_PAREN .)


state 122

    (40) value -> POW L_PAREN args R_PAREN .

    WO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    PLUS            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    MINUS           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    MULTI           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    ASTERISK        reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    DIVID           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    NO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    RSHIFT          reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LSHIFT          reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    CONJUNCT        reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LOGICSUM        reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    R_PAREN         reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    $end            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    R_S_BRACKET     reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    COMMA           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    DIVREAL         reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    GA              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    EQUAL           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    NOT             reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    NOT2            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LESS            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LESS_EQUAL      reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    GREATER         reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    GREATER_EQUAL   reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    TO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    DE              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    KARA            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    MADE            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    KO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    R_C_BRACKET     reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)


state 123

    (37) statement -> TYPE COLON NAME ASSIGN NAME . L_PAREN args R_PAREN
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 153
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    $end            reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 79
    NO              shift and go to state 80

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 124

    (6) statement -> TYPE COLON NAME ASSIGN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    $end            reduce using rule 6 (statement -> TYPE COLON NAME ASSIGN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 125

    (4) decl_names_m -> COMMA NAME . decl_names_m
    (4) decl_names_m -> . COMMA NAME decl_names_m
    (5) decl_names_m -> .

    COMMA           shift and go to state 89
    $end            reduce using rule 5 (decl_names_m -> .)

    decl_names_m                   shift and go to state 154

state 126

    (8) statement -> TYPE NO ARRAY COLON NAME . ASSIGN init_array
    (38) statement -> TYPE NO ARRAY COLON NAME . ASSIGN NAME L_PAREN args R_PAREN

    ASSIGN          shift and go to state 155


state 127

    (16) statement -> TYPE ARRAY NO ARRAY COLON . NAME ASSIGN init_array2d

    NAME            shift and go to state 156


state 128

    (36) statement -> NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 157


state 129

    (74) value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET . value R_S_BRACKET
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 158

state 130

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 159

state 131

    (73) value -> NAME L_S_BRACKET value R_S_BRACKET NO . VALUE
    (76) value -> NAME L_S_BRACKET value R_S_BRACKET NO . ARR_LEN

    VALUE           shift and go to state 160
    ARR_LEN         shift and go to state 161


state 132

    (39) statement -> NAME NO END NI NAME . L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 162
    WO              reduce using rule 70 (value -> NAME .)
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 79
    NO              shift and go to state 80

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 133

    (15) statement -> NAME NO END NI value . WO ADD
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    WO              shift and go to state 163
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 134

    (33) args_m -> COMMA value . args_m
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value
    (33) args_m -> . COMMA value args_m
    (34) args_m -> .

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39
    COMMA           shift and go to state 97
    R_PAREN         reduce using rule 34 (args_m -> .)

    args_m                         shift and go to state 164

state 135

    (84) division_tail -> NO SHOW .

    WO              reduce using rule 84 (division_tail -> NO SHOW .)
    PLUS            reduce using rule 84 (division_tail -> NO SHOW .)
    MINUS           reduce using rule 84 (division_tail -> NO SHOW .)
    MULTI           reduce using rule 84 (division_tail -> NO SHOW .)
    ASTERISK        reduce using rule 84 (division_tail -> NO SHOW .)
    DIVID           reduce using rule 84 (division_tail -> NO SHOW .)
    NO              reduce using rule 84 (division_tail -> NO SHOW .)
    RSHIFT          reduce using rule 84 (division_tail -> NO SHOW .)
    LSHIFT          reduce using rule 84 (division_tail -> NO SHOW .)
    CONJUNCT        reduce using rule 84 (division_tail -> NO SHOW .)
    LOGICSUM        reduce using rule 84 (division_tail -> NO SHOW .)
    R_PAREN         reduce using rule 84 (division_tail -> NO SHOW .)
    $end            reduce using rule 84 (division_tail -> NO SHOW .)
    R_S_BRACKET     reduce using rule 84 (division_tail -> NO SHOW .)
    COMMA           reduce using rule 84 (division_tail -> NO SHOW .)
    DIVREAL         reduce using rule 84 (division_tail -> NO SHOW .)
    GA              reduce using rule 84 (division_tail -> NO SHOW .)
    EQUAL           reduce using rule 84 (division_tail -> NO SHOW .)
    NOT             reduce using rule 84 (division_tail -> NO SHOW .)
    NOT2            reduce using rule 84 (division_tail -> NO SHOW .)
    LESS            reduce using rule 84 (division_tail -> NO SHOW .)
    LESS_EQUAL      reduce using rule 84 (division_tail -> NO SHOW .)
    GREATER         reduce using rule 84 (division_tail -> NO SHOW .)
    GREATER_EQUAL   reduce using rule 84 (division_tail -> NO SHOW .)
    TO              reduce using rule 84 (division_tail -> NO SHOW .)
    DE              reduce using rule 84 (division_tail -> NO SHOW .)
    KARA            reduce using rule 84 (division_tail -> NO SHOW .)
    MADE            reduce using rule 84 (division_tail -> NO SHOW .)
    KO              reduce using rule 84 (division_tail -> NO SHOW .)
    R_C_BRACKET     reduce using rule 84 (division_tail -> NO SHOW .)


state 136

    (85) division_tail -> NO REMAINDER .

    WO              reduce using rule 85 (division_tail -> NO REMAINDER .)
    PLUS            reduce using rule 85 (division_tail -> NO REMAINDER .)
    MINUS           reduce using rule 85 (division_tail -> NO REMAINDER .)
    MULTI           reduce using rule 85 (division_tail -> NO REMAINDER .)
    ASTERISK        reduce using rule 85 (division_tail -> NO REMAINDER .)
    DIVID           reduce using rule 85 (division_tail -> NO REMAINDER .)
    NO              reduce using rule 85 (division_tail -> NO REMAINDER .)
    RSHIFT          reduce using rule 85 (division_tail -> NO REMAINDER .)
    LSHIFT          reduce using rule 85 (division_tail -> NO REMAINDER .)
    CONJUNCT        reduce using rule 85 (division_tail -> NO REMAINDER .)
    LOGICSUM        reduce using rule 85 (division_tail -> NO REMAINDER .)
    R_PAREN         reduce using rule 85 (division_tail -> NO REMAINDER .)
    $end            reduce using rule 85 (division_tail -> NO REMAINDER .)
    R_S_BRACKET     reduce using rule 85 (division_tail -> NO REMAINDER .)
    COMMA           reduce using rule 85 (division_tail -> NO REMAINDER .)
    DIVREAL         reduce using rule 85 (division_tail -> NO REMAINDER .)
    GA              reduce using rule 85 (division_tail -> NO REMAINDER .)
    EQUAL           reduce using rule 85 (division_tail -> NO REMAINDER .)
    NOT             reduce using rule 85 (division_tail -> NO REMAINDER .)
    NOT2            reduce using rule 85 (division_tail -> NO REMAINDER .)
    LESS            reduce using rule 85 (division_tail -> NO REMAINDER .)
    LESS_EQUAL      reduce using rule 85 (division_tail -> NO REMAINDER .)
    GREATER         reduce using rule 85 (division_tail -> NO REMAINDER .)
    GREATER_EQUAL   reduce using rule 85 (division_tail -> NO REMAINDER .)
    TO              reduce using rule 85 (division_tail -> NO REMAINDER .)
    DE              reduce using rule 85 (division_tail -> NO REMAINDER .)
    KARA            reduce using rule 85 (division_tail -> NO REMAINDER .)
    MADE            reduce using rule 85 (division_tail -> NO REMAINDER .)
    KO              reduce using rule 85 (division_tail -> NO REMAINDER .)
    R_C_BRACKET     reduce using rule 85 (division_tail -> NO REMAINDER .)


state 137

    (88) value -> value NO DECIMAL_P BELOW WO . ROUNDED_UP VALUE

    ROUNDED_UP      shift and go to state 165


state 138

    (17) statement -> GLOBAL COLON TYPE ARRAY NO . ARRAY COLON NAME ASSIGN init_array2d

    ARRAY           shift and go to state 166


state 139

    (28) statement -> CIRCLE NAME L_PAREN params R_PAREN .

    $end            reduce using rule 28 (statement -> CIRCLE NAME L_PAREN params R_PAREN .)


state 140

    (23) params -> TYPE COLON . NAME params_m

    NAME            shift and go to state 167


state 141

    (24) params -> TYPE NO . ARRAY COLON NAME params_m

    ARRAY           shift and go to state 168


state 142

    (29) statement -> CIRCLE TYPE COLON NAME L_PAREN . params R_PAREN
    (22) params -> .
    (23) params -> . TYPE COLON NAME params_m
    (24) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 22 (params -> .)
    TYPE            shift and go to state 104

    params                         shift and go to state 169

state 143

    (30) statement -> CIRCLE TYPE NO ARRAY COLON . NAME L_PAREN params R_PAREN

    NAME            shift and go to state 170


state 144

    (78) value -> L_PAREN value R_PAREN NO RESULT .

    WO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    PLUS            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    MINUS           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    MULTI           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    ASTERISK        reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    DIVID           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    NO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    RSHIFT          reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LSHIFT          reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    CONJUNCT        reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LOGICSUM        reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_PAREN         reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    $end            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_S_BRACKET     reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    COMMA           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    DIVREAL         reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    GA              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    EQUAL           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    NOT             reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    NOT2            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LESS            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LESS_EQUAL      reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    GREATER         reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    GREATER_EQUAL   reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    TO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    DE              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    KARA            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    MADE            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    KO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_C_BRACKET     reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)


state 145

    (89) value -> L_PAREN value R_PAREN NO DECIMAL_P . BELOW WO ROUNDED_UP VALUE

    BELOW           shift and go to state 171


state 146

    (72) value -> NAME L_S_BRACKET value R_S_BRACKET .
    (73) value -> NAME L_S_BRACKET value R_S_BRACKET . NO VALUE
    (74) value -> NAME L_S_BRACKET value R_S_BRACKET . L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value R_S_BRACKET . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    R_PAREN         reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    ASTERISK        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    RSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    CONJUNCT        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LOGICSUM        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    $end            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    WO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    R_S_BRACKET     reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    COMMA           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVREAL         reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GA              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    EQUAL           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NOT             reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NOT2            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LESS            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LESS_EQUAL      reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GREATER         reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GREATER_EQUAL   reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    TO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DE              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    KARA            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MADE            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    KO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    R_C_BRACKET     reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NO              shift and go to state 131
    L_S_BRACKET     shift and go to state 129

  ! NO              [ reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .) ]


state 147

    (47) conditional -> value sign value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    R_PAREN         reduce using rule 47 (conditional -> value sign value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 148

    (57) conditional -> value GA value . TO HITOSHII
    (58) conditional -> value GA value . TO NOTHITOSHII
    (59) conditional -> value GA value . DE DIVISIBLE
    (60) conditional -> value GA value . TO value DE DIVISIBLE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    TO              shift and go to state 172
    DE              shift and go to state 173
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 149

    (49) sign -> NOT EQUAL .

    POW             reduce using rule 49 (sign -> NOT EQUAL .)
    NUMBER          reduce using rule 49 (sign -> NOT EQUAL .)
    MINUS           reduce using rule 49 (sign -> NOT EQUAL .)
    FLOAT           reduce using rule 49 (sign -> NOT EQUAL .)
    NAME            reduce using rule 49 (sign -> NOT EQUAL .)
    STRING          reduce using rule 49 (sign -> NOT EQUAL .)
    L_PAREN         reduce using rule 49 (sign -> NOT EQUAL .)


state 150

    (52) sign -> LESS EQUAL .

    POW             reduce using rule 52 (sign -> LESS EQUAL .)
    NUMBER          reduce using rule 52 (sign -> LESS EQUAL .)
    MINUS           reduce using rule 52 (sign -> LESS EQUAL .)
    FLOAT           reduce using rule 52 (sign -> LESS EQUAL .)
    NAME            reduce using rule 52 (sign -> LESS EQUAL .)
    STRING          reduce using rule 52 (sign -> LESS EQUAL .)
    L_PAREN         reduce using rule 52 (sign -> LESS EQUAL .)


state 151

    (55) sign -> GREATER EQUAL .

    POW             reduce using rule 55 (sign -> GREATER EQUAL .)
    NUMBER          reduce using rule 55 (sign -> GREATER EQUAL .)
    MINUS           reduce using rule 55 (sign -> GREATER EQUAL .)
    FLOAT           reduce using rule 55 (sign -> GREATER EQUAL .)
    NAME            reduce using rule 55 (sign -> GREATER EQUAL .)
    STRING          reduce using rule 55 (sign -> GREATER EQUAL .)
    L_PAREN         reduce using rule 55 (sign -> GREATER EQUAL .)


state 152

    (61) statement -> FOR L_PAREN NAME WO value . KARA value MADE NUMBER ZUTSU incdec R_PAREN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    KARA            shift and go to state 174
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 153

    (37) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 175
    value                          shift and go to state 62

state 154

    (4) decl_names_m -> COMMA NAME decl_names_m .

    $end            reduce using rule 4 (decl_names_m -> COMMA NAME decl_names_m .)


state 155

    (8) statement -> TYPE NO ARRAY COLON NAME ASSIGN . init_array
    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN . NAME L_PAREN args R_PAREN
    (9) init_array -> . L_C_BRACKET R_C_BRACKET
    (10) init_array -> . L_C_BRACKET init_array_val R_C_BRACKET
    (13) init_array -> . L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET

    NAME            shift and go to state 176
    L_C_BRACKET     shift and go to state 178

    init_array                     shift and go to state 177

state 156

    (16) statement -> TYPE ARRAY NO ARRAY COLON NAME . ASSIGN init_array2d

    ASSIGN          shift and go to state 179


state 157

    (36) statement -> NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 36 (statement -> NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 158

    (74) value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value . R_S_BRACKET
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    R_S_BRACKET     shift and go to state 180
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 159

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    $end            reduce using rule 14 (statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 160

    (73) value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .

    WO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    PLUS            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MINUS           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MULTI           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    ASTERISK        reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DIVID           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    RSHIFT          reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LSHIFT          reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    CONJUNCT        reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LOGICSUM        reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_PAREN         reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    $end            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_S_BRACKET     reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    COMMA           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DIVREAL         reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GA              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    EQUAL           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NOT             reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NOT2            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LESS            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LESS_EQUAL      reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GREATER         reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GREATER_EQUAL   reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    TO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DE              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    KARA            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MADE            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    KO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_C_BRACKET     reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)


state 161

    (76) value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .

    WO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    PLUS            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    MINUS           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    MULTI           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    ASTERISK        reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    DIVID           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    NO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    RSHIFT          reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LSHIFT          reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    CONJUNCT        reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LOGICSUM        reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    R_PAREN         reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    $end            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    R_S_BRACKET     reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    COMMA           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    DIVREAL         reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    GA              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    EQUAL           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    NOT             reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    NOT2            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LESS            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LESS_EQUAL      reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    GREATER         reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    GREATER_EQUAL   reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    TO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    DE              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    KARA            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    MADE            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    KO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    R_C_BRACKET     reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)


state 162

    (39) statement -> NAME NO END NI NAME L_PAREN . args R_PAREN NO RETURN_VAL WO ADD
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 181
    value                          shift and go to state 62

state 163

    (15) statement -> NAME NO END NI value WO . ADD

    ADD             shift and go to state 182


state 164

    (33) args_m -> COMMA value args_m .

    R_PAREN         reduce using rule 33 (args_m -> COMMA value args_m .)


state 165

    (88) value -> value NO DECIMAL_P BELOW WO ROUNDED_UP . VALUE

    VALUE           shift and go to state 183


state 166

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY . COLON NAME ASSIGN init_array2d

    COLON           shift and go to state 184


state 167

    (23) params -> TYPE COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 186
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 185

state 168

    (24) params -> TYPE NO ARRAY . COLON NAME params_m

    COLON           shift and go to state 187


state 169

    (29) statement -> CIRCLE TYPE COLON NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 188


state 170

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 189


state 171

    (89) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW . WO ROUNDED_UP VALUE

    WO              shift and go to state 190


state 172

    (57) conditional -> value GA value TO . HITOSHII
    (58) conditional -> value GA value TO . NOTHITOSHII
    (60) conditional -> value GA value TO . value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    HITOSHII        shift and go to state 192
    NOTHITOSHII     shift and go to state 193
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 191

state 173

    (59) conditional -> value GA value DE . DIVISIBLE

    DIVISIBLE       shift and go to state 194


state 174

    (61) statement -> FOR L_PAREN NAME WO value KARA . value MADE NUMBER ZUTSU incdec R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 195

state 175

    (37) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 196


state 176

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME . L_PAREN args R_PAREN

    L_PAREN         shift and go to state 197


state 177

    (8) statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array .

    $end            reduce using rule 8 (statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array .)


state 178

    (9) init_array -> L_C_BRACKET . R_C_BRACKET
    (10) init_array -> L_C_BRACKET . init_array_val R_C_BRACKET
    (13) init_array -> L_C_BRACKET . value KO NO UNDEF NO VALUE R_C_BRACKET
    (11) init_array_val -> . init_array_val COMMA value
    (12) init_array_val -> . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    R_C_BRACKET     shift and go to state 198
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    init_array_val                 shift and go to state 199
    value                          shift and go to state 200

state 179

    (16) statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN . init_array2d
    (18) init_array2d -> . L_C_BRACKET init_array2d_val R_C_BRACKET

    L_C_BRACKET     shift and go to state 202

    init_array2d                   shift and go to state 201

state 180

    (74) value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .

    WO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    ASTERISK        reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    NO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    RSHIFT          reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LSHIFT          reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    CONJUNCT        reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LOGICSUM        reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    R_PAREN         reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    $end            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    R_S_BRACKET     reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    COMMA           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    DIVREAL         reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    GA              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    EQUAL           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    NOT             reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    NOT2            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LESS            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LESS_EQUAL      reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    GREATER         reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    GREATER_EQUAL   reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    TO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    DE              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    KARA            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    MADE            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    KO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    R_C_BRACKET     reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)


state 181

    (39) statement -> NAME NO END NI NAME L_PAREN args . R_PAREN NO RETURN_VAL WO ADD

    R_PAREN         shift and go to state 203


state 182

    (15) statement -> NAME NO END NI value WO ADD .

    $end            reduce using rule 15 (statement -> NAME NO END NI value WO ADD .)


state 183

    (88) value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .

    WO              reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    PLUS            reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MINUS           reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MULTI           reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    ASTERISK        reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVID           reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NO              reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    RSHIFT          reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LSHIFT          reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    CONJUNCT        reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LOGICSUM        reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_PAREN         reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    $end            reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_S_BRACKET     reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    COMMA           reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVREAL         reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GA              reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    EQUAL           reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT             reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT2            reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS            reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS_EQUAL      reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER         reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER_EQUAL   reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    TO              reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DE              reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KARA            reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MADE            reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KO              reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_C_BRACKET     reduce using rule 88 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)


state 184

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON . NAME ASSIGN init_array2d

    NAME            shift and go to state 204


state 185

    (23) params -> TYPE COLON NAME params_m .

    R_PAREN         reduce using rule 23 (params -> TYPE COLON NAME params_m .)


state 186

    (25) params_m -> COMMA . TYPE COLON NAME params_m
    (26) params_m -> COMMA . TYPE NO ARRAY COLON NAME params_m

    TYPE            shift and go to state 205


state 187

    (24) params -> TYPE NO ARRAY COLON . NAME params_m

    NAME            shift and go to state 206


state 188

    (29) statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN .

    $end            reduce using rule 29 (statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN .)


state 189

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN . params R_PAREN
    (22) params -> .
    (23) params -> . TYPE COLON NAME params_m
    (24) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 22 (params -> .)
    TYPE            shift and go to state 104

    params                         shift and go to state 207

state 190

    (89) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO . ROUNDED_UP VALUE

    ROUNDED_UP      shift and go to state 208


state 191

    (60) conditional -> value GA value TO value . DE DIVISIBLE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    DE              shift and go to state 209
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 192

    (57) conditional -> value GA value TO HITOSHII .

    R_PAREN         reduce using rule 57 (conditional -> value GA value TO HITOSHII .)


state 193

    (58) conditional -> value GA value TO NOTHITOSHII .

    R_PAREN         reduce using rule 58 (conditional -> value GA value TO NOTHITOSHII .)


state 194

    (59) conditional -> value GA value DE DIVISIBLE .

    R_PAREN         reduce using rule 59 (conditional -> value GA value DE DIVISIBLE .)


state 195

    (61) statement -> FOR L_PAREN NAME WO value KARA value . MADE NUMBER ZUTSU incdec R_PAREN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    MADE            shift and go to state 210
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 196

    (37) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 37 (statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 197

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 211
    value                          shift and go to state 62

state 198

    (9) init_array -> L_C_BRACKET R_C_BRACKET .

    $end            reduce using rule 9 (init_array -> L_C_BRACKET R_C_BRACKET .)
    R_C_BRACKET     reduce using rule 9 (init_array -> L_C_BRACKET R_C_BRACKET .)
    COMMA           reduce using rule 9 (init_array -> L_C_BRACKET R_C_BRACKET .)


state 199

    (10) init_array -> L_C_BRACKET init_array_val . R_C_BRACKET
    (11) init_array_val -> init_array_val . COMMA value

    R_C_BRACKET     shift and go to state 212
    COMMA           shift and go to state 213


state 200

    (13) init_array -> L_C_BRACKET value . KO NO UNDEF NO VALUE R_C_BRACKET
    (12) init_array_val -> value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    KO              shift and go to state 214
    R_C_BRACKET     reduce using rule 12 (init_array_val -> value .)
    COMMA           reduce using rule 12 (init_array_val -> value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 201

    (16) statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .

    $end            reduce using rule 16 (statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .)


state 202

    (18) init_array2d -> L_C_BRACKET . init_array2d_val R_C_BRACKET
    (19) init_array2d_val -> . init_array2d_val COMMA init_array
    (20) init_array2d_val -> . init_array
    (9) init_array -> . L_C_BRACKET R_C_BRACKET
    (10) init_array -> . L_C_BRACKET init_array_val R_C_BRACKET
    (13) init_array -> . L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET

    L_C_BRACKET     shift and go to state 178

    init_array2d_val               shift and go to state 215
    init_array                     shift and go to state 216

state 203

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN . NO RETURN_VAL WO ADD

    NO              shift and go to state 217


state 204

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME . ASSIGN init_array2d

    ASSIGN          shift and go to state 218


state 205

    (25) params_m -> COMMA TYPE . COLON NAME params_m
    (26) params_m -> COMMA TYPE . NO ARRAY COLON NAME params_m

    COLON           shift and go to state 219
    NO              shift and go to state 220


state 206

    (24) params -> TYPE NO ARRAY COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 186
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 221

state 207

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 222


state 208

    (89) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP . VALUE

    VALUE           shift and go to state 223


state 209

    (60) conditional -> value GA value TO value DE . DIVISIBLE

    DIVISIBLE       shift and go to state 224


state 210

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE . NUMBER ZUTSU incdec R_PAREN

    NUMBER          shift and go to state 225


state 211

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 226


state 212

    (10) init_array -> L_C_BRACKET init_array_val R_C_BRACKET .

    $end            reduce using rule 10 (init_array -> L_C_BRACKET init_array_val R_C_BRACKET .)
    R_C_BRACKET     reduce using rule 10 (init_array -> L_C_BRACKET init_array_val R_C_BRACKET .)
    COMMA           reduce using rule 10 (init_array -> L_C_BRACKET init_array_val R_C_BRACKET .)


state 213

    (11) init_array_val -> init_array_val COMMA . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (88) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (89) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . value RSHIFT value
    (91) value -> . value LSHIFT value
    (92) value -> . value CONJUNCT value
    (93) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 44
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 227

state 214

    (13) init_array -> L_C_BRACKET value KO . NO UNDEF NO VALUE R_C_BRACKET

    NO              shift and go to state 228


state 215

    (18) init_array2d -> L_C_BRACKET init_array2d_val . R_C_BRACKET
    (19) init_array2d_val -> init_array2d_val . COMMA init_array

    R_C_BRACKET     shift and go to state 229
    COMMA           shift and go to state 230


state 216

    (20) init_array2d_val -> init_array .

    R_C_BRACKET     reduce using rule 20 (init_array2d_val -> init_array .)
    COMMA           reduce using rule 20 (init_array2d_val -> init_array .)


state 217

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO . RETURN_VAL WO ADD

    RETURN_VAL      shift and go to state 231


state 218

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN . init_array2d
    (18) init_array2d -> . L_C_BRACKET init_array2d_val R_C_BRACKET

    L_C_BRACKET     shift and go to state 202

    init_array2d                   shift and go to state 232

state 219

    (25) params_m -> COMMA TYPE COLON . NAME params_m

    NAME            shift and go to state 233


state 220

    (26) params_m -> COMMA TYPE NO . ARRAY COLON NAME params_m

    ARRAY           shift and go to state 234


state 221

    (24) params -> TYPE NO ARRAY COLON NAME params_m .

    R_PAREN         reduce using rule 24 (params -> TYPE NO ARRAY COLON NAME params_m .)


state 222

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN .

    $end            reduce using rule 30 (statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN .)


state 223

    (89) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .

    WO              reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    PLUS            reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MINUS           reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MULTI           reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    ASTERISK        reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVID           reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NO              reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    RSHIFT          reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LSHIFT          reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    CONJUNCT        reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LOGICSUM        reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_PAREN         reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    $end            reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_S_BRACKET     reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    COMMA           reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVREAL         reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GA              reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    EQUAL           reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT             reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT2            reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS            reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS_EQUAL      reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER         reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER_EQUAL   reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    TO              reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DE              reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KARA            reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MADE            reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KO              reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_C_BRACKET     reduce using rule 89 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)


state 224

    (60) conditional -> value GA value TO value DE DIVISIBLE .

    R_PAREN         reduce using rule 60 (conditional -> value GA value TO value DE DIVISIBLE .)


state 225

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER . ZUTSU incdec R_PAREN

    ZUTSU           shift and go to state 235


state 226

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 38 (statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 227

    (11) init_array_val -> init_array_val COMMA value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (88) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> value . RSHIFT value
    (91) value -> value . LSHIFT value
    (92) value -> value . CONJUNCT value
    (93) value -> value . LOGICSUM value

    R_C_BRACKET     reduce using rule 11 (init_array_val -> init_array_val COMMA value .)
    COMMA           reduce using rule 11 (init_array_val -> init_array_val COMMA value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    NO              shift and go to state 35
    RSHIFT          shift and go to state 36
    LSHIFT          shift and go to state 37
    CONJUNCT        shift and go to state 38
    LOGICSUM        shift and go to state 39


state 228

    (13) init_array -> L_C_BRACKET value KO NO . UNDEF NO VALUE R_C_BRACKET

    UNDEF           shift and go to state 236


state 229

    (18) init_array2d -> L_C_BRACKET init_array2d_val R_C_BRACKET .

    $end            reduce using rule 18 (init_array2d -> L_C_BRACKET init_array2d_val R_C_BRACKET .)


state 230

    (19) init_array2d_val -> init_array2d_val COMMA . init_array
    (9) init_array -> . L_C_BRACKET R_C_BRACKET
    (10) init_array -> . L_C_BRACKET init_array_val R_C_BRACKET
    (13) init_array -> . L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET

    L_C_BRACKET     shift and go to state 178

    init_array                     shift and go to state 237

state 231

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL . WO ADD

    WO              shift and go to state 238


state 232

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .

    $end            reduce using rule 17 (statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .)


state 233

    (25) params_m -> COMMA TYPE COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 186
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 239

state 234

    (26) params_m -> COMMA TYPE NO ARRAY . COLON NAME params_m

    COLON           shift and go to state 240


state 235

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU . incdec R_PAREN
    (62) incdec -> . INCREASE
    (63) incdec -> . DECREASE

    INCREASE        shift and go to state 242
    DECREASE        shift and go to state 243

    incdec                         shift and go to state 241

state 236

    (13) init_array -> L_C_BRACKET value KO NO UNDEF . NO VALUE R_C_BRACKET

    NO              shift and go to state 244


state 237

    (19) init_array2d_val -> init_array2d_val COMMA init_array .

    R_C_BRACKET     reduce using rule 19 (init_array2d_val -> init_array2d_val COMMA init_array .)
    COMMA           reduce using rule 19 (init_array2d_val -> init_array2d_val COMMA init_array .)


state 238

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO . ADD

    ADD             shift and go to state 245


state 239

    (25) params_m -> COMMA TYPE COLON NAME params_m .

    R_PAREN         reduce using rule 25 (params_m -> COMMA TYPE COLON NAME params_m .)


state 240

    (26) params_m -> COMMA TYPE NO ARRAY COLON . NAME params_m

    NAME            shift and go to state 246


state 241

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec . R_PAREN

    R_PAREN         shift and go to state 247


state 242

    (62) incdec -> INCREASE .

    R_PAREN         reduce using rule 62 (incdec -> INCREASE .)


state 243

    (63) incdec -> DECREASE .

    R_PAREN         reduce using rule 63 (incdec -> DECREASE .)


state 244

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO . VALUE R_C_BRACKET

    VALUE           shift and go to state 248


state 245

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD .

    $end            reduce using rule 39 (statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD .)


state 246

    (26) params_m -> COMMA TYPE NO ARRAY COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 186
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 249

state 247

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN .

    $end            reduce using rule 61 (statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN .)


state 248

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE . R_C_BRACKET

    R_C_BRACKET     shift and go to state 250


state 249

    (26) params_m -> COMMA TYPE NO ARRAY COLON NAME params_m .

    R_PAREN         reduce using rule 26 (params_m -> COMMA TYPE NO ARRAY COLON NAME params_m .)


state 250

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .

    $end            reduce using rule 13 (init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .)
    R_C_BRACKET     reduce using rule 13 (init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .)
    COMMA           reduce using rule 13 (init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NO in state 3 resolved as shift
WARNING: shift/reduce conflict for NO in state 44 resolved as shift
WARNING: shift/reduce conflict for NO in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 67 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 67 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 67 resolved as shift
WARNING: shift/reduce conflict for NO in state 67 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 67 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 67 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 67 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 67 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 68 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 68 resolved as shift
WARNING: shift/reduce conflict for NO in state 68 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 68 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 68 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 68 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVREAL in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 72 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 72 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 72 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 72 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 72 resolved as shift
WARNING: shift/reduce conflict for NO in state 72 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 72 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 72 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 72 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 72 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 73 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 73 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 73 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 73 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 73 resolved as shift
WARNING: shift/reduce conflict for NO in state 73 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 73 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 73 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 73 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 73 resolved as shift
WARNING: shift/reduce conflict for NO in state 78 resolved as shift
WARNING: shift/reduce conflict for NO in state 93 resolved as shift
WARNING: shift/reduce conflict for NO in state 123 resolved as shift
WARNING: shift/reduce conflict for NO in state 132 resolved as shift
WARNING: shift/reduce conflict for NO in state 146 resolved as shift
