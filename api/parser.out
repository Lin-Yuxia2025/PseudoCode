Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    INDIVISIBLE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> <empty>
Rule 2     statement -> TYPE COLON decl_names
Rule 3     decl_names -> NAME decl_names_m
Rule 4     decl_names_m -> COMMA NAME decl_names_m
Rule 5     decl_names_m -> <empty>
Rule 6     statement -> TYPE COLON NAME ASSIGN value
Rule 7     statement -> NAME ASSIGN value
Rule 8     statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array
Rule 9     init_array -> L_C_BRACKET R_C_BRACKET
Rule 10    init_array -> L_C_BRACKET init_array_val R_C_BRACKET
Rule 11    init_array_val -> init_array_val COMMA value
Rule 12    init_array_val -> value
Rule 13    init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET
Rule 14    statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value
Rule 15    statement -> NAME NO END NI value WO ADD
Rule 16    statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
Rule 17    statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
Rule 18    init_array2d -> L_C_BRACKET init_array2d_val R_C_BRACKET
Rule 19    init_array2d_val -> init_array2d_val COMMA init_array
Rule 20    init_array2d_val -> init_array
Rule 21    statement -> value WO OUT
Rule 22    params -> <empty>
Rule 23    params -> TYPE COLON NAME params_m
Rule 24    params -> TYPE NO ARRAY COLON NAME params_m
Rule 25    params_m -> COMMA TYPE COLON NAME params_m
Rule 26    params_m -> COMMA TYPE NO ARRAY COLON NAME params_m
Rule 27    params_m -> <empty>
Rule 28    statement -> CIRCLE NAME L_PAREN params R_PAREN
Rule 29    statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN
Rule 30    statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN
Rule 31    args -> <empty>
Rule 32    args -> value args_m
Rule 33    args_m -> COMMA value args_m
Rule 34    args_m -> <empty>
Rule 35    statement -> NAME L_PAREN args R_PAREN
Rule 36    statement -> NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 37    statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 38    statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 39    statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
Rule 40    value -> POW L_PAREN args R_PAREN
Rule 41    statement -> RETURN
Rule 42    statement -> RETURN value
Rule 43    statement -> IF L_PAREN conditional R_PAREN
Rule 44    statement -> ELSEIF L_PAREN conditional R_PAREN
Rule 45    statement -> ELSE
Rule 46    statement -> ENDIF
Rule 47    conditional -> value sign value
Rule 48    sign -> EQUAL
Rule 49    sign -> NOT EQUAL
Rule 50    sign -> NOT2
Rule 51    sign -> LESS
Rule 52    sign -> LESS EQUAL
Rule 53    sign -> LESS_EQUAL
Rule 54    sign -> GREATER
Rule 55    sign -> GREATER EQUAL
Rule 56    sign -> GREATER_EQUAL
Rule 57    conditional -> value GA value TO HITOSHII
Rule 58    conditional -> value GA value TO NOTHITOSHII
Rule 59    conditional -> value GA value DE DIVISIBLE
Rule 60    conditional -> value GA value TO value DE DIVISIBLE
Rule 61    statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN
Rule 62    incdec -> INCREASE
Rule 63    incdec -> DECREASE
Rule 64    statement -> ENDFOR
Rule 65    statement -> WHILE L_PAREN conditional R_PAREN
Rule 66    statement -> DO
Rule 67    value -> NUMBER
Rule 68    value -> MINUS value
Rule 69    value -> FLOAT
Rule 70    value -> NAME
Rule 71    value -> STRING
Rule 72    value -> NAME L_S_BRACKET value R_S_BRACKET
Rule 73    value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE
Rule 74    value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
Rule 75    value -> NAME NO ARR_LEN
Rule 76    value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
Rule 77    value -> L_PAREN value R_PAREN
Rule 78    value -> L_PAREN value R_PAREN NO RESULT
Rule 79    value -> value PLUS value
Rule 80    value -> value MINUS value
Rule 81    value -> value MULTI value
Rule 82    value -> value ASTERISK value
Rule 83    value -> value DIVID value division_tail
Rule 84    value -> value SLASH value division_tail
Rule 85    division_tail -> NO SHOW
Rule 86    division_tail -> NO REMAINDER
Rule 87    division_tail -> DIVREAL
Rule 88    division_tail -> <empty>
Rule 89    value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
Rule 90    value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
Rule 91    value -> value RSHIFT value
Rule 92    value -> value LSHIFT value
Rule 93    value -> value CONJUNCT value
Rule 94    value -> value LOGICSUM value

Terminals, with rules where they appear

ADD                  : 15 39
ARRAY                : 8 16 16 17 17 24 26 30 38
ARR_LEN              : 75 76
ASSIGN               : 6 7 8 14 16 17 36 37 38
ASTERISK             : 82
BELOW                : 89 90
CIRCLE               : 28 29 30
COLON                : 2 6 8 16 17 17 23 24 25 26 29 30 37 38
COMMA                : 4 11 19 25 26 33
COMMENT              : 
CONJUNCT             : 93
DE                   : 59 60
DECIMAL_P            : 89 90
DECREASE             : 63
DIVID                : 83
DIVISIBLE            : 59 60
DIVREAL              : 87
DO                   : 66
ELSE                 : 45
ELSEIF               : 44
END                  : 15 39
ENDFOR               : 64
ENDIF                : 46
EQUAL                : 48 49 52 55
FLOAT                : 69
FOR                  : 61
GA                   : 57 58 59 60
GLOBAL               : 17
GREATER              : 54 55
GREATER_EQUAL        : 56
HITOSHII             : 57
IF                   : 43
INCREASE             : 62
INDIVISIBLE          : 
KARA                 : 61
KO                   : 13
LESS                 : 51 52
LESS_EQUAL           : 53
LOGICSUM             : 94
LSHIFT               : 92
L_C_BRACKET          : 9 10 13 18
L_PAREN              : 28 29 30 35 36 37 38 39 40 43 44 61 65 77 78 90
L_S_BRACKET          : 14 72 73 74 74 76
MADE                 : 61
MINUS                : 68 80
MULTI                : 81
NAME                 : 3 4 6 7 8 14 15 16 17 23 24 25 26 28 29 30 35 36 36 37 37 38 38 39 39 61 70 72 73 74 75 76
NI                   : 15 39
NO                   : 8 13 13 15 16 17 24 26 30 38 39 39 73 75 76 78 85 86 89 90
NOT                  : 49
NOT2                 : 50
NOTHITOSHII          : 58
NUMBER               : 61 67
OUT                  : 21
PLUS                 : 79
POW                  : 40
REMAINDER            : 86
RESULT               : 78
RETURN               : 41 42
RETURN_VAL           : 39
ROUNDED_UP           : 89 90
RSHIFT               : 91
R_C_BRACKET          : 9 10 13 18
R_PAREN              : 28 29 30 35 36 37 38 39 40 43 44 61 65 77 78 90
R_S_BRACKET          : 14 72 73 74 74 76
SHOW                 : 85
SLASH                : 84
STRING               : 71
TO                   : 57 58 60
TYPE                 : 2 6 8 16 17 23 24 25 26 29 30 37 38
UNDEF                : 13
VALUE                : 13 73 89 90
WHILE                : 65
WO                   : 15 21 39 61 89 90
ZUTSU                : 61
error                : 

Nonterminals, with rules where they appear

args                 : 35 36 37 38 39 40
args_m               : 32 33
conditional          : 43 44 65
decl_names           : 2
decl_names_m         : 3 4
division_tail        : 83 84
incdec               : 61
init_array           : 8 19 20
init_array2d         : 16 17
init_array2d_val     : 18 19
init_array_val       : 10 11
params               : 28 29 30
params_m             : 23 24 25 26
sign                 : 47
statement            : 0
value                : 6 7 11 12 13 14 14 15 21 32 33 42 47 47 57 57 58 58 59 59 60 60 60 61 61 68 72 73 74 74 76 77 78 79 79 80 80 81 81 82 82 83 83 84 84 89 90 91 91 92 92 93 93 94 94

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> .
    (2) statement -> . TYPE COLON decl_names
    (6) statement -> . TYPE COLON NAME ASSIGN value
    (7) statement -> . NAME ASSIGN value
    (8) statement -> . TYPE NO ARRAY COLON NAME ASSIGN init_array
    (14) statement -> . NAME L_S_BRACKET value R_S_BRACKET ASSIGN value
    (15) statement -> . NAME NO END NI value WO ADD
    (16) statement -> . TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
    (17) statement -> . GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
    (21) statement -> . value WO OUT
    (28) statement -> . CIRCLE NAME L_PAREN params R_PAREN
    (29) statement -> . CIRCLE TYPE COLON NAME L_PAREN params R_PAREN
    (30) statement -> . CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN
    (35) statement -> . NAME L_PAREN args R_PAREN
    (36) statement -> . NAME ASSIGN NAME L_PAREN args R_PAREN
    (37) statement -> . TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (38) statement -> . TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (39) statement -> . NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (41) statement -> . RETURN
    (42) statement -> . RETURN value
    (43) statement -> . IF L_PAREN conditional R_PAREN
    (44) statement -> . ELSEIF L_PAREN conditional R_PAREN
    (45) statement -> . ELSE
    (46) statement -> . ENDIF
    (61) statement -> . FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN
    (64) statement -> . ENDFOR
    (65) statement -> . WHILE L_PAREN conditional R_PAREN
    (66) statement -> . DO
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    $end            reduce using rule 1 (statement -> .)
    TYPE            shift and go to state 2
    NAME            shift and go to state 3
    GLOBAL          shift and go to state 5
    CIRCLE          shift and go to state 6
    RETURN          shift and go to state 8
    IF              shift and go to state 9
    ELSEIF          shift and go to state 10
    ELSE            shift and go to state 11
    ENDIF           shift and go to state 12
    FOR             shift and go to state 13
    ENDFOR          shift and go to state 15
    WHILE           shift and go to state 16
    DO              shift and go to state 17
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    statement                      shift and go to state 1
    value                          shift and go to state 4

state 1

    (0) S' -> statement .



state 2

    (2) statement -> TYPE . COLON decl_names
    (6) statement -> TYPE . COLON NAME ASSIGN value
    (8) statement -> TYPE . NO ARRAY COLON NAME ASSIGN init_array
    (16) statement -> TYPE . ARRAY NO ARRAY COLON NAME ASSIGN init_array2d
    (37) statement -> TYPE . COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (38) statement -> TYPE . NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    COLON           shift and go to state 22
    NO              shift and go to state 23
    ARRAY           shift and go to state 24


state 3

    (7) statement -> NAME . ASSIGN value
    (14) statement -> NAME . L_S_BRACKET value R_S_BRACKET ASSIGN value
    (15) statement -> NAME . NO END NI value WO ADD
    (35) statement -> NAME . L_PAREN args R_PAREN
    (36) statement -> NAME . ASSIGN NAME L_PAREN args R_PAREN
    (39) statement -> NAME . NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    ASSIGN          shift and go to state 25
    L_S_BRACKET     shift and go to state 26
    NO              shift and go to state 27
    L_PAREN         shift and go to state 28
    WO              reduce using rule 70 (value -> NAME .)
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    SLASH           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 4

    (21) statement -> value . WO OUT
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              shift and go to state 29
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 5

    (17) statement -> GLOBAL . COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d

    COLON           shift and go to state 41


state 6

    (28) statement -> CIRCLE . NAME L_PAREN params R_PAREN
    (29) statement -> CIRCLE . TYPE COLON NAME L_PAREN params R_PAREN
    (30) statement -> CIRCLE . TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN

    NAME            shift and go to state 42
    TYPE            shift and go to state 43


state 7

    (77) value -> L_PAREN . value R_PAREN
    (78) value -> L_PAREN . value R_PAREN NO RESULT
    (90) value -> L_PAREN . value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 44

state 8

    (41) statement -> RETURN .
    (42) statement -> RETURN . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    $end            reduce using rule 41 (statement -> RETURN .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 46

state 9

    (43) statement -> IF . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 47


state 10

    (44) statement -> ELSEIF . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 48


state 11

    (45) statement -> ELSE .

    $end            reduce using rule 45 (statement -> ELSE .)


state 12

    (46) statement -> ENDIF .

    $end            reduce using rule 46 (statement -> ENDIF .)


state 13

    (61) statement -> FOR . L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN

    L_PAREN         shift and go to state 49


state 14

    (67) value -> NUMBER .

    WO              reduce using rule 67 (value -> NUMBER .)
    PLUS            reduce using rule 67 (value -> NUMBER .)
    MINUS           reduce using rule 67 (value -> NUMBER .)
    MULTI           reduce using rule 67 (value -> NUMBER .)
    ASTERISK        reduce using rule 67 (value -> NUMBER .)
    DIVID           reduce using rule 67 (value -> NUMBER .)
    SLASH           reduce using rule 67 (value -> NUMBER .)
    NO              reduce using rule 67 (value -> NUMBER .)
    RSHIFT          reduce using rule 67 (value -> NUMBER .)
    LSHIFT          reduce using rule 67 (value -> NUMBER .)
    CONJUNCT        reduce using rule 67 (value -> NUMBER .)
    LOGICSUM        reduce using rule 67 (value -> NUMBER .)
    R_PAREN         reduce using rule 67 (value -> NUMBER .)
    $end            reduce using rule 67 (value -> NUMBER .)
    R_S_BRACKET     reduce using rule 67 (value -> NUMBER .)
    COMMA           reduce using rule 67 (value -> NUMBER .)
    DIVREAL         reduce using rule 67 (value -> NUMBER .)
    GA              reduce using rule 67 (value -> NUMBER .)
    EQUAL           reduce using rule 67 (value -> NUMBER .)
    NOT             reduce using rule 67 (value -> NUMBER .)
    NOT2            reduce using rule 67 (value -> NUMBER .)
    LESS            reduce using rule 67 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 67 (value -> NUMBER .)
    GREATER         reduce using rule 67 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 67 (value -> NUMBER .)
    TO              reduce using rule 67 (value -> NUMBER .)
    DE              reduce using rule 67 (value -> NUMBER .)
    KARA            reduce using rule 67 (value -> NUMBER .)
    MADE            reduce using rule 67 (value -> NUMBER .)
    KO              reduce using rule 67 (value -> NUMBER .)
    R_C_BRACKET     reduce using rule 67 (value -> NUMBER .)


state 15

    (64) statement -> ENDFOR .

    $end            reduce using rule 64 (statement -> ENDFOR .)


state 16

    (65) statement -> WHILE . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 50


state 17

    (66) statement -> DO .

    $end            reduce using rule 66 (statement -> DO .)


state 18

    (40) value -> POW . L_PAREN args R_PAREN

    L_PAREN         shift and go to state 51


state 19

    (68) value -> MINUS . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 52

state 20

    (69) value -> FLOAT .

    WO              reduce using rule 69 (value -> FLOAT .)
    PLUS            reduce using rule 69 (value -> FLOAT .)
    MINUS           reduce using rule 69 (value -> FLOAT .)
    MULTI           reduce using rule 69 (value -> FLOAT .)
    ASTERISK        reduce using rule 69 (value -> FLOAT .)
    DIVID           reduce using rule 69 (value -> FLOAT .)
    SLASH           reduce using rule 69 (value -> FLOAT .)
    NO              reduce using rule 69 (value -> FLOAT .)
    RSHIFT          reduce using rule 69 (value -> FLOAT .)
    LSHIFT          reduce using rule 69 (value -> FLOAT .)
    CONJUNCT        reduce using rule 69 (value -> FLOAT .)
    LOGICSUM        reduce using rule 69 (value -> FLOAT .)
    R_PAREN         reduce using rule 69 (value -> FLOAT .)
    $end            reduce using rule 69 (value -> FLOAT .)
    R_S_BRACKET     reduce using rule 69 (value -> FLOAT .)
    COMMA           reduce using rule 69 (value -> FLOAT .)
    DIVREAL         reduce using rule 69 (value -> FLOAT .)
    GA              reduce using rule 69 (value -> FLOAT .)
    EQUAL           reduce using rule 69 (value -> FLOAT .)
    NOT             reduce using rule 69 (value -> FLOAT .)
    NOT2            reduce using rule 69 (value -> FLOAT .)
    LESS            reduce using rule 69 (value -> FLOAT .)
    LESS_EQUAL      reduce using rule 69 (value -> FLOAT .)
    GREATER         reduce using rule 69 (value -> FLOAT .)
    GREATER_EQUAL   reduce using rule 69 (value -> FLOAT .)
    TO              reduce using rule 69 (value -> FLOAT .)
    DE              reduce using rule 69 (value -> FLOAT .)
    KARA            reduce using rule 69 (value -> FLOAT .)
    MADE            reduce using rule 69 (value -> FLOAT .)
    KO              reduce using rule 69 (value -> FLOAT .)
    R_C_BRACKET     reduce using rule 69 (value -> FLOAT .)


state 21

    (71) value -> STRING .

    WO              reduce using rule 71 (value -> STRING .)
    PLUS            reduce using rule 71 (value -> STRING .)
    MINUS           reduce using rule 71 (value -> STRING .)
    MULTI           reduce using rule 71 (value -> STRING .)
    ASTERISK        reduce using rule 71 (value -> STRING .)
    DIVID           reduce using rule 71 (value -> STRING .)
    SLASH           reduce using rule 71 (value -> STRING .)
    NO              reduce using rule 71 (value -> STRING .)
    RSHIFT          reduce using rule 71 (value -> STRING .)
    LSHIFT          reduce using rule 71 (value -> STRING .)
    CONJUNCT        reduce using rule 71 (value -> STRING .)
    LOGICSUM        reduce using rule 71 (value -> STRING .)
    R_PAREN         reduce using rule 71 (value -> STRING .)
    $end            reduce using rule 71 (value -> STRING .)
    R_S_BRACKET     reduce using rule 71 (value -> STRING .)
    COMMA           reduce using rule 71 (value -> STRING .)
    DIVREAL         reduce using rule 71 (value -> STRING .)
    GA              reduce using rule 71 (value -> STRING .)
    EQUAL           reduce using rule 71 (value -> STRING .)
    NOT             reduce using rule 71 (value -> STRING .)
    NOT2            reduce using rule 71 (value -> STRING .)
    LESS            reduce using rule 71 (value -> STRING .)
    LESS_EQUAL      reduce using rule 71 (value -> STRING .)
    GREATER         reduce using rule 71 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 71 (value -> STRING .)
    TO              reduce using rule 71 (value -> STRING .)
    DE              reduce using rule 71 (value -> STRING .)
    KARA            reduce using rule 71 (value -> STRING .)
    MADE            reduce using rule 71 (value -> STRING .)
    KO              reduce using rule 71 (value -> STRING .)
    R_C_BRACKET     reduce using rule 71 (value -> STRING .)


state 22

    (2) statement -> TYPE COLON . decl_names
    (6) statement -> TYPE COLON . NAME ASSIGN value
    (37) statement -> TYPE COLON . NAME ASSIGN NAME L_PAREN args R_PAREN
    (3) decl_names -> . NAME decl_names_m

    NAME            shift and go to state 54

    decl_names                     shift and go to state 53

state 23

    (8) statement -> TYPE NO . ARRAY COLON NAME ASSIGN init_array
    (38) statement -> TYPE NO . ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    ARRAY           shift and go to state 55


state 24

    (16) statement -> TYPE ARRAY . NO ARRAY COLON NAME ASSIGN init_array2d

    NO              shift and go to state 56


state 25

    (7) statement -> NAME ASSIGN . value
    (36) statement -> NAME ASSIGN . NAME L_PAREN args R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    NAME            shift and go to state 57
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 58

state 26

    (14) statement -> NAME L_S_BRACKET . value R_S_BRACKET ASSIGN value
    (72) value -> NAME L_S_BRACKET . value R_S_BRACKET
    (73) value -> NAME L_S_BRACKET . value R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET . value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET . value R_S_BRACKET NO ARR_LEN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 59

state 27

    (15) statement -> NAME NO . END NI value WO ADD
    (39) statement -> NAME NO . END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (75) value -> NAME NO . ARR_LEN

    END             shift and go to state 60
    ARR_LEN         shift and go to state 61


state 28

    (35) statement -> NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 62
    value                          shift and go to state 63

state 29

    (21) statement -> value WO . OUT

    OUT             shift and go to state 64


state 30

    (79) value -> value PLUS . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 65

state 31

    (80) value -> value MINUS . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 66

state 32

    (81) value -> value MULTI . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 67

state 33

    (82) value -> value ASTERISK . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 68

state 34

    (83) value -> value DIVID . value division_tail
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 69

state 35

    (84) value -> value SLASH . value division_tail
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 70

state 36

    (89) value -> value NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE

    DECIMAL_P       shift and go to state 71


state 37

    (91) value -> value RSHIFT . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 72

state 38

    (92) value -> value LSHIFT . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 73

state 39

    (93) value -> value CONJUNCT . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 74

state 40

    (94) value -> value LOGICSUM . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 75

state 41

    (17) statement -> GLOBAL COLON . TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d

    TYPE            shift and go to state 76


state 42

    (28) statement -> CIRCLE NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 77


state 43

    (29) statement -> CIRCLE TYPE . COLON NAME L_PAREN params R_PAREN
    (30) statement -> CIRCLE TYPE . NO ARRAY COLON NAME L_PAREN params R_PAREN

    COLON           shift and go to state 78
    NO              shift and go to state 79


state 44

    (77) value -> L_PAREN value . R_PAREN
    (78) value -> L_PAREN value . R_PAREN NO RESULT
    (90) value -> L_PAREN value . R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    R_PAREN         shift and go to state 80
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 45

    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    R_PAREN         reduce using rule 70 (value -> NAME .)
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    SLASH           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    $end            reduce using rule 70 (value -> NAME .)
    WO              reduce using rule 70 (value -> NAME .)
    R_S_BRACKET     reduce using rule 70 (value -> NAME .)
    COMMA           reduce using rule 70 (value -> NAME .)
    DIVREAL         reduce using rule 70 (value -> NAME .)
    GA              reduce using rule 70 (value -> NAME .)
    EQUAL           reduce using rule 70 (value -> NAME .)
    NOT             reduce using rule 70 (value -> NAME .)
    NOT2            reduce using rule 70 (value -> NAME .)
    LESS            reduce using rule 70 (value -> NAME .)
    LESS_EQUAL      reduce using rule 70 (value -> NAME .)
    GREATER         reduce using rule 70 (value -> NAME .)
    GREATER_EQUAL   reduce using rule 70 (value -> NAME .)
    TO              reduce using rule 70 (value -> NAME .)
    DE              reduce using rule 70 (value -> NAME .)
    KARA            reduce using rule 70 (value -> NAME .)
    MADE            reduce using rule 70 (value -> NAME .)
    KO              reduce using rule 70 (value -> NAME .)
    R_C_BRACKET     reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 81
    NO              shift and go to state 82

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 46

    (42) statement -> RETURN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    $end            reduce using rule 42 (statement -> RETURN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 47

    (43) statement -> IF L_PAREN . conditional R_PAREN
    (47) conditional -> . value sign value
    (57) conditional -> . value GA value TO HITOSHII
    (58) conditional -> . value GA value TO NOTHITOSHII
    (59) conditional -> . value GA value DE DIVISIBLE
    (60) conditional -> . value GA value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    conditional                    shift and go to state 83
    value                          shift and go to state 84

state 48

    (44) statement -> ELSEIF L_PAREN . conditional R_PAREN
    (47) conditional -> . value sign value
    (57) conditional -> . value GA value TO HITOSHII
    (58) conditional -> . value GA value TO NOTHITOSHII
    (59) conditional -> . value GA value DE DIVISIBLE
    (60) conditional -> . value GA value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    conditional                    shift and go to state 85
    value                          shift and go to state 84

state 49

    (61) statement -> FOR L_PAREN . NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN

    NAME            shift and go to state 86


state 50

    (65) statement -> WHILE L_PAREN . conditional R_PAREN
    (47) conditional -> . value sign value
    (57) conditional -> . value GA value TO HITOSHII
    (58) conditional -> . value GA value TO NOTHITOSHII
    (59) conditional -> . value GA value DE DIVISIBLE
    (60) conditional -> . value GA value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    conditional                    shift and go to state 87
    value                          shift and go to state 84

state 51

    (40) value -> POW L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 88
    value                          shift and go to state 63

state 52

    (68) value -> MINUS value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              reduce using rule 68 (value -> MINUS value .)
    PLUS            reduce using rule 68 (value -> MINUS value .)
    MINUS           reduce using rule 68 (value -> MINUS value .)
    MULTI           reduce using rule 68 (value -> MINUS value .)
    ASTERISK        reduce using rule 68 (value -> MINUS value .)
    DIVID           reduce using rule 68 (value -> MINUS value .)
    SLASH           reduce using rule 68 (value -> MINUS value .)
    NO              reduce using rule 68 (value -> MINUS value .)
    RSHIFT          reduce using rule 68 (value -> MINUS value .)
    LSHIFT          reduce using rule 68 (value -> MINUS value .)
    CONJUNCT        reduce using rule 68 (value -> MINUS value .)
    LOGICSUM        reduce using rule 68 (value -> MINUS value .)
    R_PAREN         reduce using rule 68 (value -> MINUS value .)
    $end            reduce using rule 68 (value -> MINUS value .)
    R_S_BRACKET     reduce using rule 68 (value -> MINUS value .)
    COMMA           reduce using rule 68 (value -> MINUS value .)
    DIVREAL         reduce using rule 68 (value -> MINUS value .)
    GA              reduce using rule 68 (value -> MINUS value .)
    EQUAL           reduce using rule 68 (value -> MINUS value .)
    NOT             reduce using rule 68 (value -> MINUS value .)
    NOT2            reduce using rule 68 (value -> MINUS value .)
    LESS            reduce using rule 68 (value -> MINUS value .)
    LESS_EQUAL      reduce using rule 68 (value -> MINUS value .)
    GREATER         reduce using rule 68 (value -> MINUS value .)
    GREATER_EQUAL   reduce using rule 68 (value -> MINUS value .)
    TO              reduce using rule 68 (value -> MINUS value .)
    DE              reduce using rule 68 (value -> MINUS value .)
    KARA            reduce using rule 68 (value -> MINUS value .)
    MADE            reduce using rule 68 (value -> MINUS value .)
    KO              reduce using rule 68 (value -> MINUS value .)
    R_C_BRACKET     reduce using rule 68 (value -> MINUS value .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! MULTI           [ shift and go to state 32 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! DIVID           [ shift and go to state 34 ]
  ! SLASH           [ shift and go to state 35 ]
  ! NO              [ shift and go to state 36 ]
  ! RSHIFT          [ shift and go to state 37 ]
  ! LSHIFT          [ shift and go to state 38 ]
  ! CONJUNCT        [ shift and go to state 39 ]
  ! LOGICSUM        [ shift and go to state 40 ]


state 53

    (2) statement -> TYPE COLON decl_names .

    $end            reduce using rule 2 (statement -> TYPE COLON decl_names .)


state 54

    (6) statement -> TYPE COLON NAME . ASSIGN value
    (37) statement -> TYPE COLON NAME . ASSIGN NAME L_PAREN args R_PAREN
    (3) decl_names -> NAME . decl_names_m
    (4) decl_names_m -> . COMMA NAME decl_names_m
    (5) decl_names_m -> .

    ASSIGN          shift and go to state 89
    COMMA           shift and go to state 91
    $end            reduce using rule 5 (decl_names_m -> .)

    decl_names_m                   shift and go to state 90

state 55

    (8) statement -> TYPE NO ARRAY . COLON NAME ASSIGN init_array
    (38) statement -> TYPE NO ARRAY . COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    COLON           shift and go to state 92


state 56

    (16) statement -> TYPE ARRAY NO . ARRAY COLON NAME ASSIGN init_array2d

    ARRAY           shift and go to state 93


state 57

    (36) statement -> NAME ASSIGN NAME . L_PAREN args R_PAREN
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 94
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    SLASH           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    $end            reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 81
    NO              shift and go to state 82

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 58

    (7) statement -> NAME ASSIGN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    $end            reduce using rule 7 (statement -> NAME ASSIGN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 59

    (14) statement -> NAME L_S_BRACKET value . R_S_BRACKET ASSIGN value
    (72) value -> NAME L_S_BRACKET value . R_S_BRACKET
    (73) value -> NAME L_S_BRACKET value . R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET value . R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value . R_S_BRACKET NO ARR_LEN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    R_S_BRACKET     shift and go to state 95
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 60

    (15) statement -> NAME NO END . NI value WO ADD
    (39) statement -> NAME NO END . NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD

    NI              shift and go to state 96


state 61

    (75) value -> NAME NO ARR_LEN .

    WO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    PLUS            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    MINUS           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    MULTI           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    ASTERISK        reduce using rule 75 (value -> NAME NO ARR_LEN .)
    DIVID           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    SLASH           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    NO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    RSHIFT          reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LSHIFT          reduce using rule 75 (value -> NAME NO ARR_LEN .)
    CONJUNCT        reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LOGICSUM        reduce using rule 75 (value -> NAME NO ARR_LEN .)
    R_PAREN         reduce using rule 75 (value -> NAME NO ARR_LEN .)
    $end            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    R_S_BRACKET     reduce using rule 75 (value -> NAME NO ARR_LEN .)
    COMMA           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    DIVREAL         reduce using rule 75 (value -> NAME NO ARR_LEN .)
    GA              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    EQUAL           reduce using rule 75 (value -> NAME NO ARR_LEN .)
    NOT             reduce using rule 75 (value -> NAME NO ARR_LEN .)
    NOT2            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LESS            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    LESS_EQUAL      reduce using rule 75 (value -> NAME NO ARR_LEN .)
    GREATER         reduce using rule 75 (value -> NAME NO ARR_LEN .)
    GREATER_EQUAL   reduce using rule 75 (value -> NAME NO ARR_LEN .)
    TO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    DE              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    KARA            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    MADE            reduce using rule 75 (value -> NAME NO ARR_LEN .)
    KO              reduce using rule 75 (value -> NAME NO ARR_LEN .)
    R_C_BRACKET     reduce using rule 75 (value -> NAME NO ARR_LEN .)


state 62

    (35) statement -> NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 97


state 63

    (32) args -> value . args_m
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value
    (33) args_m -> . COMMA value args_m
    (34) args_m -> .

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40
    COMMA           shift and go to state 99
    R_PAREN         reduce using rule 34 (args_m -> .)

    args_m                         shift and go to state 98

state 64

    (21) statement -> value WO OUT .

    $end            reduce using rule 21 (statement -> value WO OUT .)


state 65

    (79) value -> value PLUS value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              reduce using rule 79 (value -> value PLUS value .)
    PLUS            reduce using rule 79 (value -> value PLUS value .)
    MINUS           reduce using rule 79 (value -> value PLUS value .)
    ASTERISK        reduce using rule 79 (value -> value PLUS value .)
    SLASH           reduce using rule 79 (value -> value PLUS value .)
    NO              reduce using rule 79 (value -> value PLUS value .)
    RSHIFT          reduce using rule 79 (value -> value PLUS value .)
    LSHIFT          reduce using rule 79 (value -> value PLUS value .)
    CONJUNCT        reduce using rule 79 (value -> value PLUS value .)
    LOGICSUM        reduce using rule 79 (value -> value PLUS value .)
    R_PAREN         reduce using rule 79 (value -> value PLUS value .)
    $end            reduce using rule 79 (value -> value PLUS value .)
    R_S_BRACKET     reduce using rule 79 (value -> value PLUS value .)
    COMMA           reduce using rule 79 (value -> value PLUS value .)
    DIVREAL         reduce using rule 79 (value -> value PLUS value .)
    GA              reduce using rule 79 (value -> value PLUS value .)
    EQUAL           reduce using rule 79 (value -> value PLUS value .)
    NOT             reduce using rule 79 (value -> value PLUS value .)
    NOT2            reduce using rule 79 (value -> value PLUS value .)
    LESS            reduce using rule 79 (value -> value PLUS value .)
    LESS_EQUAL      reduce using rule 79 (value -> value PLUS value .)
    GREATER         reduce using rule 79 (value -> value PLUS value .)
    GREATER_EQUAL   reduce using rule 79 (value -> value PLUS value .)
    TO              reduce using rule 79 (value -> value PLUS value .)
    DE              reduce using rule 79 (value -> value PLUS value .)
    KARA            reduce using rule 79 (value -> value PLUS value .)
    MADE            reduce using rule 79 (value -> value PLUS value .)
    KO              reduce using rule 79 (value -> value PLUS value .)
    R_C_BRACKET     reduce using rule 79 (value -> value PLUS value .)
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! MULTI           [ reduce using rule 79 (value -> value PLUS value .) ]
  ! DIVID           [ reduce using rule 79 (value -> value PLUS value .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! SLASH           [ shift and go to state 35 ]
  ! NO              [ shift and go to state 36 ]
  ! RSHIFT          [ shift and go to state 37 ]
  ! LSHIFT          [ shift and go to state 38 ]
  ! CONJUNCT        [ shift and go to state 39 ]
  ! LOGICSUM        [ shift and go to state 40 ]


state 66

    (80) value -> value MINUS value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              reduce using rule 80 (value -> value MINUS value .)
    PLUS            reduce using rule 80 (value -> value MINUS value .)
    MINUS           reduce using rule 80 (value -> value MINUS value .)
    ASTERISK        reduce using rule 80 (value -> value MINUS value .)
    SLASH           reduce using rule 80 (value -> value MINUS value .)
    NO              reduce using rule 80 (value -> value MINUS value .)
    RSHIFT          reduce using rule 80 (value -> value MINUS value .)
    LSHIFT          reduce using rule 80 (value -> value MINUS value .)
    CONJUNCT        reduce using rule 80 (value -> value MINUS value .)
    LOGICSUM        reduce using rule 80 (value -> value MINUS value .)
    R_PAREN         reduce using rule 80 (value -> value MINUS value .)
    $end            reduce using rule 80 (value -> value MINUS value .)
    R_S_BRACKET     reduce using rule 80 (value -> value MINUS value .)
    COMMA           reduce using rule 80 (value -> value MINUS value .)
    DIVREAL         reduce using rule 80 (value -> value MINUS value .)
    GA              reduce using rule 80 (value -> value MINUS value .)
    EQUAL           reduce using rule 80 (value -> value MINUS value .)
    NOT             reduce using rule 80 (value -> value MINUS value .)
    NOT2            reduce using rule 80 (value -> value MINUS value .)
    LESS            reduce using rule 80 (value -> value MINUS value .)
    LESS_EQUAL      reduce using rule 80 (value -> value MINUS value .)
    GREATER         reduce using rule 80 (value -> value MINUS value .)
    GREATER_EQUAL   reduce using rule 80 (value -> value MINUS value .)
    TO              reduce using rule 80 (value -> value MINUS value .)
    DE              reduce using rule 80 (value -> value MINUS value .)
    KARA            reduce using rule 80 (value -> value MINUS value .)
    MADE            reduce using rule 80 (value -> value MINUS value .)
    KO              reduce using rule 80 (value -> value MINUS value .)
    R_C_BRACKET     reduce using rule 80 (value -> value MINUS value .)
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! MULTI           [ reduce using rule 80 (value -> value MINUS value .) ]
  ! DIVID           [ reduce using rule 80 (value -> value MINUS value .) ]
  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! SLASH           [ shift and go to state 35 ]
  ! NO              [ shift and go to state 36 ]
  ! RSHIFT          [ shift and go to state 37 ]
  ! LSHIFT          [ shift and go to state 38 ]
  ! CONJUNCT        [ shift and go to state 39 ]
  ! LOGICSUM        [ shift and go to state 40 ]


state 67

    (81) value -> value MULTI value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              reduce using rule 81 (value -> value MULTI value .)
    PLUS            reduce using rule 81 (value -> value MULTI value .)
    MINUS           reduce using rule 81 (value -> value MULTI value .)
    MULTI           reduce using rule 81 (value -> value MULTI value .)
    ASTERISK        reduce using rule 81 (value -> value MULTI value .)
    DIVID           reduce using rule 81 (value -> value MULTI value .)
    SLASH           reduce using rule 81 (value -> value MULTI value .)
    NO              reduce using rule 81 (value -> value MULTI value .)
    RSHIFT          reduce using rule 81 (value -> value MULTI value .)
    LSHIFT          reduce using rule 81 (value -> value MULTI value .)
    CONJUNCT        reduce using rule 81 (value -> value MULTI value .)
    LOGICSUM        reduce using rule 81 (value -> value MULTI value .)
    R_PAREN         reduce using rule 81 (value -> value MULTI value .)
    $end            reduce using rule 81 (value -> value MULTI value .)
    R_S_BRACKET     reduce using rule 81 (value -> value MULTI value .)
    COMMA           reduce using rule 81 (value -> value MULTI value .)
    DIVREAL         reduce using rule 81 (value -> value MULTI value .)
    GA              reduce using rule 81 (value -> value MULTI value .)
    EQUAL           reduce using rule 81 (value -> value MULTI value .)
    NOT             reduce using rule 81 (value -> value MULTI value .)
    NOT2            reduce using rule 81 (value -> value MULTI value .)
    LESS            reduce using rule 81 (value -> value MULTI value .)
    LESS_EQUAL      reduce using rule 81 (value -> value MULTI value .)
    GREATER         reduce using rule 81 (value -> value MULTI value .)
    GREATER_EQUAL   reduce using rule 81 (value -> value MULTI value .)
    TO              reduce using rule 81 (value -> value MULTI value .)
    DE              reduce using rule 81 (value -> value MULTI value .)
    KARA            reduce using rule 81 (value -> value MULTI value .)
    MADE            reduce using rule 81 (value -> value MULTI value .)
    KO              reduce using rule 81 (value -> value MULTI value .)
    R_C_BRACKET     reduce using rule 81 (value -> value MULTI value .)

  ! PLUS            [ shift and go to state 30 ]
  ! MINUS           [ shift and go to state 31 ]
  ! MULTI           [ shift and go to state 32 ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! DIVID           [ shift and go to state 34 ]
  ! SLASH           [ shift and go to state 35 ]
  ! NO              [ shift and go to state 36 ]
  ! RSHIFT          [ shift and go to state 37 ]
  ! LSHIFT          [ shift and go to state 38 ]
  ! CONJUNCT        [ shift and go to state 39 ]
  ! LOGICSUM        [ shift and go to state 40 ]


state 68

    (82) value -> value ASTERISK value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for SLASH resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
    WO              reduce using rule 82 (value -> value ASTERISK value .)
    R_PAREN         reduce using rule 82 (value -> value ASTERISK value .)
    $end            reduce using rule 82 (value -> value ASTERISK value .)
    R_S_BRACKET     reduce using rule 82 (value -> value ASTERISK value .)
    COMMA           reduce using rule 82 (value -> value ASTERISK value .)
    DIVREAL         reduce using rule 82 (value -> value ASTERISK value .)
    GA              reduce using rule 82 (value -> value ASTERISK value .)
    EQUAL           reduce using rule 82 (value -> value ASTERISK value .)
    NOT             reduce using rule 82 (value -> value ASTERISK value .)
    NOT2            reduce using rule 82 (value -> value ASTERISK value .)
    LESS            reduce using rule 82 (value -> value ASTERISK value .)
    LESS_EQUAL      reduce using rule 82 (value -> value ASTERISK value .)
    GREATER         reduce using rule 82 (value -> value ASTERISK value .)
    GREATER_EQUAL   reduce using rule 82 (value -> value ASTERISK value .)
    TO              reduce using rule 82 (value -> value ASTERISK value .)
    DE              reduce using rule 82 (value -> value ASTERISK value .)
    KARA            reduce using rule 82 (value -> value ASTERISK value .)
    MADE            reduce using rule 82 (value -> value ASTERISK value .)
    KO              reduce using rule 82 (value -> value ASTERISK value .)
    R_C_BRACKET     reduce using rule 82 (value -> value ASTERISK value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40

  ! PLUS            [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! MINUS           [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! MULTI           [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! ASTERISK        [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! DIVID           [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! SLASH           [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! NO              [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! RSHIFT          [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! LSHIFT          [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! CONJUNCT        [ reduce using rule 82 (value -> value ASTERISK value .) ]
  ! LOGICSUM        [ reduce using rule 82 (value -> value ASTERISK value .) ]


state 69

    (83) value -> value DIVID value . division_tail
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value
    (85) division_tail -> . NO SHOW
    (86) division_tail -> . NO REMAINDER
    (87) division_tail -> . DIVREAL
    (88) division_tail -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for SLASH resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
  ! shift/reduce conflict for DIVREAL resolved as shift
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 101
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40
    DIVREAL         shift and go to state 102
    WO              reduce using rule 88 (division_tail -> .)
    R_PAREN         reduce using rule 88 (division_tail -> .)
    $end            reduce using rule 88 (division_tail -> .)
    R_S_BRACKET     reduce using rule 88 (division_tail -> .)
    COMMA           reduce using rule 88 (division_tail -> .)
    GA              reduce using rule 88 (division_tail -> .)
    EQUAL           reduce using rule 88 (division_tail -> .)
    NOT             reduce using rule 88 (division_tail -> .)
    NOT2            reduce using rule 88 (division_tail -> .)
    LESS            reduce using rule 88 (division_tail -> .)
    LESS_EQUAL      reduce using rule 88 (division_tail -> .)
    GREATER         reduce using rule 88 (division_tail -> .)
    GREATER_EQUAL   reduce using rule 88 (division_tail -> .)
    TO              reduce using rule 88 (division_tail -> .)
    DE              reduce using rule 88 (division_tail -> .)
    KARA            reduce using rule 88 (division_tail -> .)
    MADE            reduce using rule 88 (division_tail -> .)
    KO              reduce using rule 88 (division_tail -> .)
    R_C_BRACKET     reduce using rule 88 (division_tail -> .)

  ! PLUS            [ reduce using rule 88 (division_tail -> .) ]
  ! MINUS           [ reduce using rule 88 (division_tail -> .) ]
  ! MULTI           [ reduce using rule 88 (division_tail -> .) ]
  ! ASTERISK        [ reduce using rule 88 (division_tail -> .) ]
  ! DIVID           [ reduce using rule 88 (division_tail -> .) ]
  ! SLASH           [ reduce using rule 88 (division_tail -> .) ]
  ! NO              [ reduce using rule 88 (division_tail -> .) ]
  ! RSHIFT          [ reduce using rule 88 (division_tail -> .) ]
  ! LSHIFT          [ reduce using rule 88 (division_tail -> .) ]
  ! CONJUNCT        [ reduce using rule 88 (division_tail -> .) ]
  ! LOGICSUM        [ reduce using rule 88 (division_tail -> .) ]
  ! DIVREAL         [ reduce using rule 88 (division_tail -> .) ]

    division_tail                  shift and go to state 100

state 70

    (84) value -> value SLASH value . division_tail
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value
    (85) division_tail -> . NO SHOW
    (86) division_tail -> . NO REMAINDER
    (87) division_tail -> . DIVREAL
    (88) division_tail -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for SLASH resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
  ! shift/reduce conflict for DIVREAL resolved as shift
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 101
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40
    DIVREAL         shift and go to state 102
    WO              reduce using rule 88 (division_tail -> .)
    R_PAREN         reduce using rule 88 (division_tail -> .)
    $end            reduce using rule 88 (division_tail -> .)
    R_S_BRACKET     reduce using rule 88 (division_tail -> .)
    COMMA           reduce using rule 88 (division_tail -> .)
    GA              reduce using rule 88 (division_tail -> .)
    EQUAL           reduce using rule 88 (division_tail -> .)
    NOT             reduce using rule 88 (division_tail -> .)
    NOT2            reduce using rule 88 (division_tail -> .)
    LESS            reduce using rule 88 (division_tail -> .)
    LESS_EQUAL      reduce using rule 88 (division_tail -> .)
    GREATER         reduce using rule 88 (division_tail -> .)
    GREATER_EQUAL   reduce using rule 88 (division_tail -> .)
    TO              reduce using rule 88 (division_tail -> .)
    DE              reduce using rule 88 (division_tail -> .)
    KARA            reduce using rule 88 (division_tail -> .)
    MADE            reduce using rule 88 (division_tail -> .)
    KO              reduce using rule 88 (division_tail -> .)
    R_C_BRACKET     reduce using rule 88 (division_tail -> .)

  ! PLUS            [ reduce using rule 88 (division_tail -> .) ]
  ! MINUS           [ reduce using rule 88 (division_tail -> .) ]
  ! MULTI           [ reduce using rule 88 (division_tail -> .) ]
  ! ASTERISK        [ reduce using rule 88 (division_tail -> .) ]
  ! DIVID           [ reduce using rule 88 (division_tail -> .) ]
  ! SLASH           [ reduce using rule 88 (division_tail -> .) ]
  ! NO              [ reduce using rule 88 (division_tail -> .) ]
  ! RSHIFT          [ reduce using rule 88 (division_tail -> .) ]
  ! LSHIFT          [ reduce using rule 88 (division_tail -> .) ]
  ! CONJUNCT        [ reduce using rule 88 (division_tail -> .) ]
  ! LOGICSUM        [ reduce using rule 88 (division_tail -> .) ]
  ! DIVREAL         [ reduce using rule 88 (division_tail -> .) ]

    division_tail                  shift and go to state 103

state 71

    (89) value -> value NO DECIMAL_P . BELOW WO ROUNDED_UP VALUE

    BELOW           shift and go to state 104


state 72

    (91) value -> value RSHIFT value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              reduce using rule 91 (value -> value RSHIFT value .)
    ASTERISK        reduce using rule 91 (value -> value RSHIFT value .)
    SLASH           reduce using rule 91 (value -> value RSHIFT value .)
    NO              reduce using rule 91 (value -> value RSHIFT value .)
    RSHIFT          reduce using rule 91 (value -> value RSHIFT value .)
    LSHIFT          reduce using rule 91 (value -> value RSHIFT value .)
    CONJUNCT        reduce using rule 91 (value -> value RSHIFT value .)
    LOGICSUM        reduce using rule 91 (value -> value RSHIFT value .)
    R_PAREN         reduce using rule 91 (value -> value RSHIFT value .)
    $end            reduce using rule 91 (value -> value RSHIFT value .)
    R_S_BRACKET     reduce using rule 91 (value -> value RSHIFT value .)
    COMMA           reduce using rule 91 (value -> value RSHIFT value .)
    DIVREAL         reduce using rule 91 (value -> value RSHIFT value .)
    GA              reduce using rule 91 (value -> value RSHIFT value .)
    EQUAL           reduce using rule 91 (value -> value RSHIFT value .)
    NOT             reduce using rule 91 (value -> value RSHIFT value .)
    NOT2            reduce using rule 91 (value -> value RSHIFT value .)
    LESS            reduce using rule 91 (value -> value RSHIFT value .)
    LESS_EQUAL      reduce using rule 91 (value -> value RSHIFT value .)
    GREATER         reduce using rule 91 (value -> value RSHIFT value .)
    GREATER_EQUAL   reduce using rule 91 (value -> value RSHIFT value .)
    TO              reduce using rule 91 (value -> value RSHIFT value .)
    DE              reduce using rule 91 (value -> value RSHIFT value .)
    KARA            reduce using rule 91 (value -> value RSHIFT value .)
    MADE            reduce using rule 91 (value -> value RSHIFT value .)
    KO              reduce using rule 91 (value -> value RSHIFT value .)
    R_C_BRACKET     reduce using rule 91 (value -> value RSHIFT value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! PLUS            [ reduce using rule 91 (value -> value RSHIFT value .) ]
  ! MINUS           [ reduce using rule 91 (value -> value RSHIFT value .) ]
  ! MULTI           [ reduce using rule 91 (value -> value RSHIFT value .) ]
  ! DIVID           [ reduce using rule 91 (value -> value RSHIFT value .) ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! SLASH           [ shift and go to state 35 ]
  ! NO              [ shift and go to state 36 ]
  ! RSHIFT          [ shift and go to state 37 ]
  ! LSHIFT          [ shift and go to state 38 ]
  ! CONJUNCT        [ shift and go to state 39 ]
  ! LOGICSUM        [ shift and go to state 40 ]


state 73

    (92) value -> value LSHIFT value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              reduce using rule 92 (value -> value LSHIFT value .)
    ASTERISK        reduce using rule 92 (value -> value LSHIFT value .)
    SLASH           reduce using rule 92 (value -> value LSHIFT value .)
    NO              reduce using rule 92 (value -> value LSHIFT value .)
    RSHIFT          reduce using rule 92 (value -> value LSHIFT value .)
    LSHIFT          reduce using rule 92 (value -> value LSHIFT value .)
    CONJUNCT        reduce using rule 92 (value -> value LSHIFT value .)
    LOGICSUM        reduce using rule 92 (value -> value LSHIFT value .)
    R_PAREN         reduce using rule 92 (value -> value LSHIFT value .)
    $end            reduce using rule 92 (value -> value LSHIFT value .)
    R_S_BRACKET     reduce using rule 92 (value -> value LSHIFT value .)
    COMMA           reduce using rule 92 (value -> value LSHIFT value .)
    DIVREAL         reduce using rule 92 (value -> value LSHIFT value .)
    GA              reduce using rule 92 (value -> value LSHIFT value .)
    EQUAL           reduce using rule 92 (value -> value LSHIFT value .)
    NOT             reduce using rule 92 (value -> value LSHIFT value .)
    NOT2            reduce using rule 92 (value -> value LSHIFT value .)
    LESS            reduce using rule 92 (value -> value LSHIFT value .)
    LESS_EQUAL      reduce using rule 92 (value -> value LSHIFT value .)
    GREATER         reduce using rule 92 (value -> value LSHIFT value .)
    GREATER_EQUAL   reduce using rule 92 (value -> value LSHIFT value .)
    TO              reduce using rule 92 (value -> value LSHIFT value .)
    DE              reduce using rule 92 (value -> value LSHIFT value .)
    KARA            reduce using rule 92 (value -> value LSHIFT value .)
    MADE            reduce using rule 92 (value -> value LSHIFT value .)
    KO              reduce using rule 92 (value -> value LSHIFT value .)
    R_C_BRACKET     reduce using rule 92 (value -> value LSHIFT value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    DIVID           shift and go to state 34

  ! PLUS            [ reduce using rule 92 (value -> value LSHIFT value .) ]
  ! MINUS           [ reduce using rule 92 (value -> value LSHIFT value .) ]
  ! MULTI           [ reduce using rule 92 (value -> value LSHIFT value .) ]
  ! DIVID           [ reduce using rule 92 (value -> value LSHIFT value .) ]
  ! ASTERISK        [ shift and go to state 33 ]
  ! SLASH           [ shift and go to state 35 ]
  ! NO              [ shift and go to state 36 ]
  ! RSHIFT          [ shift and go to state 37 ]
  ! LSHIFT          [ shift and go to state 38 ]
  ! CONJUNCT        [ shift and go to state 39 ]
  ! LOGICSUM        [ shift and go to state 40 ]


state 74

    (93) value -> value CONJUNCT value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for SLASH resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
    WO              reduce using rule 93 (value -> value CONJUNCT value .)
    R_PAREN         reduce using rule 93 (value -> value CONJUNCT value .)
    $end            reduce using rule 93 (value -> value CONJUNCT value .)
    R_S_BRACKET     reduce using rule 93 (value -> value CONJUNCT value .)
    COMMA           reduce using rule 93 (value -> value CONJUNCT value .)
    DIVREAL         reduce using rule 93 (value -> value CONJUNCT value .)
    GA              reduce using rule 93 (value -> value CONJUNCT value .)
    EQUAL           reduce using rule 93 (value -> value CONJUNCT value .)
    NOT             reduce using rule 93 (value -> value CONJUNCT value .)
    NOT2            reduce using rule 93 (value -> value CONJUNCT value .)
    LESS            reduce using rule 93 (value -> value CONJUNCT value .)
    LESS_EQUAL      reduce using rule 93 (value -> value CONJUNCT value .)
    GREATER         reduce using rule 93 (value -> value CONJUNCT value .)
    GREATER_EQUAL   reduce using rule 93 (value -> value CONJUNCT value .)
    TO              reduce using rule 93 (value -> value CONJUNCT value .)
    DE              reduce using rule 93 (value -> value CONJUNCT value .)
    KARA            reduce using rule 93 (value -> value CONJUNCT value .)
    MADE            reduce using rule 93 (value -> value CONJUNCT value .)
    KO              reduce using rule 93 (value -> value CONJUNCT value .)
    R_C_BRACKET     reduce using rule 93 (value -> value CONJUNCT value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40

  ! PLUS            [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! MINUS           [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! MULTI           [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! ASTERISK        [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! DIVID           [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! SLASH           [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! NO              [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! RSHIFT          [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! LSHIFT          [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! CONJUNCT        [ reduce using rule 93 (value -> value CONJUNCT value .) ]
  ! LOGICSUM        [ reduce using rule 93 (value -> value CONJUNCT value .) ]


state 75

    (94) value -> value LOGICSUM value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for ASTERISK resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for SLASH resolved as shift
  ! shift/reduce conflict for NO resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for CONJUNCT resolved as shift
  ! shift/reduce conflict for LOGICSUM resolved as shift
    WO              reduce using rule 94 (value -> value LOGICSUM value .)
    R_PAREN         reduce using rule 94 (value -> value LOGICSUM value .)
    $end            reduce using rule 94 (value -> value LOGICSUM value .)
    R_S_BRACKET     reduce using rule 94 (value -> value LOGICSUM value .)
    COMMA           reduce using rule 94 (value -> value LOGICSUM value .)
    DIVREAL         reduce using rule 94 (value -> value LOGICSUM value .)
    GA              reduce using rule 94 (value -> value LOGICSUM value .)
    EQUAL           reduce using rule 94 (value -> value LOGICSUM value .)
    NOT             reduce using rule 94 (value -> value LOGICSUM value .)
    NOT2            reduce using rule 94 (value -> value LOGICSUM value .)
    LESS            reduce using rule 94 (value -> value LOGICSUM value .)
    LESS_EQUAL      reduce using rule 94 (value -> value LOGICSUM value .)
    GREATER         reduce using rule 94 (value -> value LOGICSUM value .)
    GREATER_EQUAL   reduce using rule 94 (value -> value LOGICSUM value .)
    TO              reduce using rule 94 (value -> value LOGICSUM value .)
    DE              reduce using rule 94 (value -> value LOGICSUM value .)
    KARA            reduce using rule 94 (value -> value LOGICSUM value .)
    MADE            reduce using rule 94 (value -> value LOGICSUM value .)
    KO              reduce using rule 94 (value -> value LOGICSUM value .)
    R_C_BRACKET     reduce using rule 94 (value -> value LOGICSUM value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40

  ! PLUS            [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! MINUS           [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! MULTI           [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! ASTERISK        [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! DIVID           [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! SLASH           [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! NO              [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! RSHIFT          [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! LSHIFT          [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! CONJUNCT        [ reduce using rule 94 (value -> value LOGICSUM value .) ]
  ! LOGICSUM        [ reduce using rule 94 (value -> value LOGICSUM value .) ]


state 76

    (17) statement -> GLOBAL COLON TYPE . ARRAY NO ARRAY COLON NAME ASSIGN init_array2d

    ARRAY           shift and go to state 105


state 77

    (28) statement -> CIRCLE NAME L_PAREN . params R_PAREN
    (22) params -> .
    (23) params -> . TYPE COLON NAME params_m
    (24) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 22 (params -> .)
    TYPE            shift and go to state 107

    params                         shift and go to state 106

state 78

    (29) statement -> CIRCLE TYPE COLON . NAME L_PAREN params R_PAREN

    NAME            shift and go to state 108


state 79

    (30) statement -> CIRCLE TYPE NO . ARRAY COLON NAME L_PAREN params R_PAREN

    ARRAY           shift and go to state 109


state 80

    (77) value -> L_PAREN value R_PAREN .
    (78) value -> L_PAREN value R_PAREN . NO RESULT
    (90) value -> L_PAREN value R_PAREN . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

  ! shift/reduce conflict for NO resolved as shift
    WO              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    PLUS            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    MINUS           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    MULTI           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    ASTERISK        reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    DIVID           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    SLASH           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    RSHIFT          reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LSHIFT          reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    CONJUNCT        reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LOGICSUM        reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    R_PAREN         reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    $end            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    R_S_BRACKET     reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    COMMA           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    DIVREAL         reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    GA              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    EQUAL           reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    NOT             reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    NOT2            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LESS            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    LESS_EQUAL      reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    GREATER         reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    GREATER_EQUAL   reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    TO              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    DE              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    KARA            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    MADE            reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    KO              reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    R_C_BRACKET     reduce using rule 77 (value -> L_PAREN value R_PAREN .)
    NO              shift and go to state 110

  ! NO              [ reduce using rule 77 (value -> L_PAREN value R_PAREN .) ]


state 81

    (72) value -> NAME L_S_BRACKET . value R_S_BRACKET
    (73) value -> NAME L_S_BRACKET . value R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET . value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET . value R_S_BRACKET NO ARR_LEN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 111

state 82

    (75) value -> NAME NO . ARR_LEN

    ARR_LEN         shift and go to state 61


state 83

    (43) statement -> IF L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 112


state 84

    (47) conditional -> value . sign value
    (57) conditional -> value . GA value TO HITOSHII
    (58) conditional -> value . GA value TO NOTHITOSHII
    (59) conditional -> value . GA value DE DIVISIBLE
    (60) conditional -> value . GA value TO value DE DIVISIBLE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value
    (48) sign -> . EQUAL
    (49) sign -> . NOT EQUAL
    (50) sign -> . NOT2
    (51) sign -> . LESS
    (52) sign -> . LESS EQUAL
    (53) sign -> . LESS_EQUAL
    (54) sign -> . GREATER
    (55) sign -> . GREATER EQUAL
    (56) sign -> . GREATER_EQUAL

    GA              shift and go to state 114
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40
    EQUAL           shift and go to state 115
    NOT             shift and go to state 116
    NOT2            shift and go to state 117
    LESS            shift and go to state 118
    LESS_EQUAL      shift and go to state 119
    GREATER         shift and go to state 120
    GREATER_EQUAL   shift and go to state 121

    sign                           shift and go to state 113

state 85

    (44) statement -> ELSEIF L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 122


state 86

    (61) statement -> FOR L_PAREN NAME . WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN

    WO              shift and go to state 123


state 87

    (65) statement -> WHILE L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 124


state 88

    (40) value -> POW L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 125


state 89

    (6) statement -> TYPE COLON NAME ASSIGN . value
    (37) statement -> TYPE COLON NAME ASSIGN . NAME L_PAREN args R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    NAME            shift and go to state 126
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 127

state 90

    (3) decl_names -> NAME decl_names_m .

    $end            reduce using rule 3 (decl_names -> NAME decl_names_m .)


state 91

    (4) decl_names_m -> COMMA . NAME decl_names_m

    NAME            shift and go to state 128


state 92

    (8) statement -> TYPE NO ARRAY COLON . NAME ASSIGN init_array
    (38) statement -> TYPE NO ARRAY COLON . NAME ASSIGN NAME L_PAREN args R_PAREN

    NAME            shift and go to state 129


state 93

    (16) statement -> TYPE ARRAY NO ARRAY . COLON NAME ASSIGN init_array2d

    COLON           shift and go to state 130


state 94

    (36) statement -> NAME ASSIGN NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 131
    value                          shift and go to state 63

state 95

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET . ASSIGN value
    (72) value -> NAME L_S_BRACKET value R_S_BRACKET .
    (73) value -> NAME L_S_BRACKET value R_S_BRACKET . NO VALUE
    (74) value -> NAME L_S_BRACKET value R_S_BRACKET . L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value R_S_BRACKET . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    ASSIGN          shift and go to state 133
    WO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    ASTERISK        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    SLASH           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    RSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    CONJUNCT        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LOGICSUM        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NO              shift and go to state 134
    L_S_BRACKET     shift and go to state 132

  ! NO              [ reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .) ]


state 96

    (15) statement -> NAME NO END NI . value WO ADD
    (39) statement -> NAME NO END NI . NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    NAME            shift and go to state 135
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 136

state 97

    (35) statement -> NAME L_PAREN args R_PAREN .

    $end            reduce using rule 35 (statement -> NAME L_PAREN args R_PAREN .)


state 98

    (32) args -> value args_m .

    R_PAREN         reduce using rule 32 (args -> value args_m .)


state 99

    (33) args_m -> COMMA . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 137

state 100

    (83) value -> value DIVID value division_tail .

    WO              reduce using rule 83 (value -> value DIVID value division_tail .)
    PLUS            reduce using rule 83 (value -> value DIVID value division_tail .)
    MINUS           reduce using rule 83 (value -> value DIVID value division_tail .)
    MULTI           reduce using rule 83 (value -> value DIVID value division_tail .)
    ASTERISK        reduce using rule 83 (value -> value DIVID value division_tail .)
    DIVID           reduce using rule 83 (value -> value DIVID value division_tail .)
    SLASH           reduce using rule 83 (value -> value DIVID value division_tail .)
    NO              reduce using rule 83 (value -> value DIVID value division_tail .)
    RSHIFT          reduce using rule 83 (value -> value DIVID value division_tail .)
    LSHIFT          reduce using rule 83 (value -> value DIVID value division_tail .)
    CONJUNCT        reduce using rule 83 (value -> value DIVID value division_tail .)
    LOGICSUM        reduce using rule 83 (value -> value DIVID value division_tail .)
    R_PAREN         reduce using rule 83 (value -> value DIVID value division_tail .)
    $end            reduce using rule 83 (value -> value DIVID value division_tail .)
    R_S_BRACKET     reduce using rule 83 (value -> value DIVID value division_tail .)
    COMMA           reduce using rule 83 (value -> value DIVID value division_tail .)
    DIVREAL         reduce using rule 83 (value -> value DIVID value division_tail .)
    GA              reduce using rule 83 (value -> value DIVID value division_tail .)
    EQUAL           reduce using rule 83 (value -> value DIVID value division_tail .)
    NOT             reduce using rule 83 (value -> value DIVID value division_tail .)
    NOT2            reduce using rule 83 (value -> value DIVID value division_tail .)
    LESS            reduce using rule 83 (value -> value DIVID value division_tail .)
    LESS_EQUAL      reduce using rule 83 (value -> value DIVID value division_tail .)
    GREATER         reduce using rule 83 (value -> value DIVID value division_tail .)
    GREATER_EQUAL   reduce using rule 83 (value -> value DIVID value division_tail .)
    TO              reduce using rule 83 (value -> value DIVID value division_tail .)
    DE              reduce using rule 83 (value -> value DIVID value division_tail .)
    KARA            reduce using rule 83 (value -> value DIVID value division_tail .)
    MADE            reduce using rule 83 (value -> value DIVID value division_tail .)
    KO              reduce using rule 83 (value -> value DIVID value division_tail .)
    R_C_BRACKET     reduce using rule 83 (value -> value DIVID value division_tail .)


state 101

    (89) value -> value NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (85) division_tail -> NO . SHOW
    (86) division_tail -> NO . REMAINDER

    DECIMAL_P       shift and go to state 71
    SHOW            shift and go to state 138
    REMAINDER       shift and go to state 139


state 102

    (87) division_tail -> DIVREAL .

    WO              reduce using rule 87 (division_tail -> DIVREAL .)
    PLUS            reduce using rule 87 (division_tail -> DIVREAL .)
    MINUS           reduce using rule 87 (division_tail -> DIVREAL .)
    MULTI           reduce using rule 87 (division_tail -> DIVREAL .)
    ASTERISK        reduce using rule 87 (division_tail -> DIVREAL .)
    DIVID           reduce using rule 87 (division_tail -> DIVREAL .)
    SLASH           reduce using rule 87 (division_tail -> DIVREAL .)
    NO              reduce using rule 87 (division_tail -> DIVREAL .)
    RSHIFT          reduce using rule 87 (division_tail -> DIVREAL .)
    LSHIFT          reduce using rule 87 (division_tail -> DIVREAL .)
    CONJUNCT        reduce using rule 87 (division_tail -> DIVREAL .)
    LOGICSUM        reduce using rule 87 (division_tail -> DIVREAL .)
    R_PAREN         reduce using rule 87 (division_tail -> DIVREAL .)
    $end            reduce using rule 87 (division_tail -> DIVREAL .)
    R_S_BRACKET     reduce using rule 87 (division_tail -> DIVREAL .)
    COMMA           reduce using rule 87 (division_tail -> DIVREAL .)
    DIVREAL         reduce using rule 87 (division_tail -> DIVREAL .)
    GA              reduce using rule 87 (division_tail -> DIVREAL .)
    EQUAL           reduce using rule 87 (division_tail -> DIVREAL .)
    NOT             reduce using rule 87 (division_tail -> DIVREAL .)
    NOT2            reduce using rule 87 (division_tail -> DIVREAL .)
    LESS            reduce using rule 87 (division_tail -> DIVREAL .)
    LESS_EQUAL      reduce using rule 87 (division_tail -> DIVREAL .)
    GREATER         reduce using rule 87 (division_tail -> DIVREAL .)
    GREATER_EQUAL   reduce using rule 87 (division_tail -> DIVREAL .)
    TO              reduce using rule 87 (division_tail -> DIVREAL .)
    DE              reduce using rule 87 (division_tail -> DIVREAL .)
    KARA            reduce using rule 87 (division_tail -> DIVREAL .)
    MADE            reduce using rule 87 (division_tail -> DIVREAL .)
    KO              reduce using rule 87 (division_tail -> DIVREAL .)
    R_C_BRACKET     reduce using rule 87 (division_tail -> DIVREAL .)


state 103

    (84) value -> value SLASH value division_tail .

    WO              reduce using rule 84 (value -> value SLASH value division_tail .)
    PLUS            reduce using rule 84 (value -> value SLASH value division_tail .)
    MINUS           reduce using rule 84 (value -> value SLASH value division_tail .)
    MULTI           reduce using rule 84 (value -> value SLASH value division_tail .)
    ASTERISK        reduce using rule 84 (value -> value SLASH value division_tail .)
    DIVID           reduce using rule 84 (value -> value SLASH value division_tail .)
    SLASH           reduce using rule 84 (value -> value SLASH value division_tail .)
    NO              reduce using rule 84 (value -> value SLASH value division_tail .)
    RSHIFT          reduce using rule 84 (value -> value SLASH value division_tail .)
    LSHIFT          reduce using rule 84 (value -> value SLASH value division_tail .)
    CONJUNCT        reduce using rule 84 (value -> value SLASH value division_tail .)
    LOGICSUM        reduce using rule 84 (value -> value SLASH value division_tail .)
    R_PAREN         reduce using rule 84 (value -> value SLASH value division_tail .)
    $end            reduce using rule 84 (value -> value SLASH value division_tail .)
    R_S_BRACKET     reduce using rule 84 (value -> value SLASH value division_tail .)
    COMMA           reduce using rule 84 (value -> value SLASH value division_tail .)
    DIVREAL         reduce using rule 84 (value -> value SLASH value division_tail .)
    GA              reduce using rule 84 (value -> value SLASH value division_tail .)
    EQUAL           reduce using rule 84 (value -> value SLASH value division_tail .)
    NOT             reduce using rule 84 (value -> value SLASH value division_tail .)
    NOT2            reduce using rule 84 (value -> value SLASH value division_tail .)
    LESS            reduce using rule 84 (value -> value SLASH value division_tail .)
    LESS_EQUAL      reduce using rule 84 (value -> value SLASH value division_tail .)
    GREATER         reduce using rule 84 (value -> value SLASH value division_tail .)
    GREATER_EQUAL   reduce using rule 84 (value -> value SLASH value division_tail .)
    TO              reduce using rule 84 (value -> value SLASH value division_tail .)
    DE              reduce using rule 84 (value -> value SLASH value division_tail .)
    KARA            reduce using rule 84 (value -> value SLASH value division_tail .)
    MADE            reduce using rule 84 (value -> value SLASH value division_tail .)
    KO              reduce using rule 84 (value -> value SLASH value division_tail .)
    R_C_BRACKET     reduce using rule 84 (value -> value SLASH value division_tail .)


state 104

    (89) value -> value NO DECIMAL_P BELOW . WO ROUNDED_UP VALUE

    WO              shift and go to state 140


state 105

    (17) statement -> GLOBAL COLON TYPE ARRAY . NO ARRAY COLON NAME ASSIGN init_array2d

    NO              shift and go to state 141


state 106

    (28) statement -> CIRCLE NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 142


state 107

    (23) params -> TYPE . COLON NAME params_m
    (24) params -> TYPE . NO ARRAY COLON NAME params_m

    COLON           shift and go to state 143
    NO              shift and go to state 144


state 108

    (29) statement -> CIRCLE TYPE COLON NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 145


state 109

    (30) statement -> CIRCLE TYPE NO ARRAY . COLON NAME L_PAREN params R_PAREN

    COLON           shift and go to state 146


state 110

    (78) value -> L_PAREN value R_PAREN NO . RESULT
    (90) value -> L_PAREN value R_PAREN NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE

    RESULT          shift and go to state 147
    DECIMAL_P       shift and go to state 148


state 111

    (72) value -> NAME L_S_BRACKET value . R_S_BRACKET
    (73) value -> NAME L_S_BRACKET value . R_S_BRACKET NO VALUE
    (74) value -> NAME L_S_BRACKET value . R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value . R_S_BRACKET NO ARR_LEN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    R_S_BRACKET     shift and go to state 149
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 112

    (43) statement -> IF L_PAREN conditional R_PAREN .

    $end            reduce using rule 43 (statement -> IF L_PAREN conditional R_PAREN .)


state 113

    (47) conditional -> value sign . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 150

state 114

    (57) conditional -> value GA . value TO HITOSHII
    (58) conditional -> value GA . value TO NOTHITOSHII
    (59) conditional -> value GA . value DE DIVISIBLE
    (60) conditional -> value GA . value TO value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 151

state 115

    (48) sign -> EQUAL .

    POW             reduce using rule 48 (sign -> EQUAL .)
    NUMBER          reduce using rule 48 (sign -> EQUAL .)
    MINUS           reduce using rule 48 (sign -> EQUAL .)
    FLOAT           reduce using rule 48 (sign -> EQUAL .)
    NAME            reduce using rule 48 (sign -> EQUAL .)
    STRING          reduce using rule 48 (sign -> EQUAL .)
    L_PAREN         reduce using rule 48 (sign -> EQUAL .)


state 116

    (49) sign -> NOT . EQUAL

    EQUAL           shift and go to state 152


state 117

    (50) sign -> NOT2 .

    POW             reduce using rule 50 (sign -> NOT2 .)
    NUMBER          reduce using rule 50 (sign -> NOT2 .)
    MINUS           reduce using rule 50 (sign -> NOT2 .)
    FLOAT           reduce using rule 50 (sign -> NOT2 .)
    NAME            reduce using rule 50 (sign -> NOT2 .)
    STRING          reduce using rule 50 (sign -> NOT2 .)
    L_PAREN         reduce using rule 50 (sign -> NOT2 .)


state 118

    (51) sign -> LESS .
    (52) sign -> LESS . EQUAL

    POW             reduce using rule 51 (sign -> LESS .)
    NUMBER          reduce using rule 51 (sign -> LESS .)
    MINUS           reduce using rule 51 (sign -> LESS .)
    FLOAT           reduce using rule 51 (sign -> LESS .)
    NAME            reduce using rule 51 (sign -> LESS .)
    STRING          reduce using rule 51 (sign -> LESS .)
    L_PAREN         reduce using rule 51 (sign -> LESS .)
    EQUAL           shift and go to state 153


state 119

    (53) sign -> LESS_EQUAL .

    POW             reduce using rule 53 (sign -> LESS_EQUAL .)
    NUMBER          reduce using rule 53 (sign -> LESS_EQUAL .)
    MINUS           reduce using rule 53 (sign -> LESS_EQUAL .)
    FLOAT           reduce using rule 53 (sign -> LESS_EQUAL .)
    NAME            reduce using rule 53 (sign -> LESS_EQUAL .)
    STRING          reduce using rule 53 (sign -> LESS_EQUAL .)
    L_PAREN         reduce using rule 53 (sign -> LESS_EQUAL .)


state 120

    (54) sign -> GREATER .
    (55) sign -> GREATER . EQUAL

    POW             reduce using rule 54 (sign -> GREATER .)
    NUMBER          reduce using rule 54 (sign -> GREATER .)
    MINUS           reduce using rule 54 (sign -> GREATER .)
    FLOAT           reduce using rule 54 (sign -> GREATER .)
    NAME            reduce using rule 54 (sign -> GREATER .)
    STRING          reduce using rule 54 (sign -> GREATER .)
    L_PAREN         reduce using rule 54 (sign -> GREATER .)
    EQUAL           shift and go to state 154


state 121

    (56) sign -> GREATER_EQUAL .

    POW             reduce using rule 56 (sign -> GREATER_EQUAL .)
    NUMBER          reduce using rule 56 (sign -> GREATER_EQUAL .)
    MINUS           reduce using rule 56 (sign -> GREATER_EQUAL .)
    FLOAT           reduce using rule 56 (sign -> GREATER_EQUAL .)
    NAME            reduce using rule 56 (sign -> GREATER_EQUAL .)
    STRING          reduce using rule 56 (sign -> GREATER_EQUAL .)
    L_PAREN         reduce using rule 56 (sign -> GREATER_EQUAL .)


state 122

    (44) statement -> ELSEIF L_PAREN conditional R_PAREN .

    $end            reduce using rule 44 (statement -> ELSEIF L_PAREN conditional R_PAREN .)


state 123

    (61) statement -> FOR L_PAREN NAME WO . value KARA value MADE NUMBER ZUTSU incdec R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 155

state 124

    (65) statement -> WHILE L_PAREN conditional R_PAREN .

    $end            reduce using rule 65 (statement -> WHILE L_PAREN conditional R_PAREN .)


state 125

    (40) value -> POW L_PAREN args R_PAREN .

    WO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    PLUS            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    MINUS           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    MULTI           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    ASTERISK        reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    DIVID           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    SLASH           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    NO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    RSHIFT          reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LSHIFT          reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    CONJUNCT        reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LOGICSUM        reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    R_PAREN         reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    $end            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    R_S_BRACKET     reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    COMMA           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    DIVREAL         reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    GA              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    EQUAL           reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    NOT             reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    NOT2            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LESS            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    LESS_EQUAL      reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    GREATER         reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    GREATER_EQUAL   reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    TO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    DE              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    KARA            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    MADE            reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    KO              reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)
    R_C_BRACKET     reduce using rule 40 (value -> POW L_PAREN args R_PAREN .)


state 126

    (37) statement -> TYPE COLON NAME ASSIGN NAME . L_PAREN args R_PAREN
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 156
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    SLASH           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    $end            reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 81
    NO              shift and go to state 82

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 127

    (6) statement -> TYPE COLON NAME ASSIGN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    $end            reduce using rule 6 (statement -> TYPE COLON NAME ASSIGN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 128

    (4) decl_names_m -> COMMA NAME . decl_names_m
    (4) decl_names_m -> . COMMA NAME decl_names_m
    (5) decl_names_m -> .

    COMMA           shift and go to state 91
    $end            reduce using rule 5 (decl_names_m -> .)

    decl_names_m                   shift and go to state 157

state 129

    (8) statement -> TYPE NO ARRAY COLON NAME . ASSIGN init_array
    (38) statement -> TYPE NO ARRAY COLON NAME . ASSIGN NAME L_PAREN args R_PAREN

    ASSIGN          shift and go to state 158


state 130

    (16) statement -> TYPE ARRAY NO ARRAY COLON . NAME ASSIGN init_array2d

    NAME            shift and go to state 159


state 131

    (36) statement -> NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 160


state 132

    (74) value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET . value R_S_BRACKET
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 161

state 133

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 162

state 134

    (73) value -> NAME L_S_BRACKET value R_S_BRACKET NO . VALUE
    (76) value -> NAME L_S_BRACKET value R_S_BRACKET NO . ARR_LEN

    VALUE           shift and go to state 163
    ARR_LEN         shift and go to state 164


state 135

    (39) statement -> NAME NO END NI NAME . L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (70) value -> NAME .
    (72) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (73) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> NAME . L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> NAME . NO ARR_LEN
    (76) value -> NAME . L_S_BRACKET value R_S_BRACKET NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 165
    WO              reduce using rule 70 (value -> NAME .)
    PLUS            reduce using rule 70 (value -> NAME .)
    MINUS           reduce using rule 70 (value -> NAME .)
    MULTI           reduce using rule 70 (value -> NAME .)
    ASTERISK        reduce using rule 70 (value -> NAME .)
    DIVID           reduce using rule 70 (value -> NAME .)
    SLASH           reduce using rule 70 (value -> NAME .)
    RSHIFT          reduce using rule 70 (value -> NAME .)
    LSHIFT          reduce using rule 70 (value -> NAME .)
    CONJUNCT        reduce using rule 70 (value -> NAME .)
    LOGICSUM        reduce using rule 70 (value -> NAME .)
    L_S_BRACKET     shift and go to state 81
    NO              shift and go to state 82

  ! NO              [ reduce using rule 70 (value -> NAME .) ]


state 136

    (15) statement -> NAME NO END NI value . WO ADD
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    WO              shift and go to state 166
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 137

    (33) args_m -> COMMA value . args_m
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value
    (33) args_m -> . COMMA value args_m
    (34) args_m -> .

    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40
    COMMA           shift and go to state 99
    R_PAREN         reduce using rule 34 (args_m -> .)

    args_m                         shift and go to state 167

state 138

    (85) division_tail -> NO SHOW .

    WO              reduce using rule 85 (division_tail -> NO SHOW .)
    PLUS            reduce using rule 85 (division_tail -> NO SHOW .)
    MINUS           reduce using rule 85 (division_tail -> NO SHOW .)
    MULTI           reduce using rule 85 (division_tail -> NO SHOW .)
    ASTERISK        reduce using rule 85 (division_tail -> NO SHOW .)
    DIVID           reduce using rule 85 (division_tail -> NO SHOW .)
    SLASH           reduce using rule 85 (division_tail -> NO SHOW .)
    NO              reduce using rule 85 (division_tail -> NO SHOW .)
    RSHIFT          reduce using rule 85 (division_tail -> NO SHOW .)
    LSHIFT          reduce using rule 85 (division_tail -> NO SHOW .)
    CONJUNCT        reduce using rule 85 (division_tail -> NO SHOW .)
    LOGICSUM        reduce using rule 85 (division_tail -> NO SHOW .)
    R_PAREN         reduce using rule 85 (division_tail -> NO SHOW .)
    $end            reduce using rule 85 (division_tail -> NO SHOW .)
    R_S_BRACKET     reduce using rule 85 (division_tail -> NO SHOW .)
    COMMA           reduce using rule 85 (division_tail -> NO SHOW .)
    DIVREAL         reduce using rule 85 (division_tail -> NO SHOW .)
    GA              reduce using rule 85 (division_tail -> NO SHOW .)
    EQUAL           reduce using rule 85 (division_tail -> NO SHOW .)
    NOT             reduce using rule 85 (division_tail -> NO SHOW .)
    NOT2            reduce using rule 85 (division_tail -> NO SHOW .)
    LESS            reduce using rule 85 (division_tail -> NO SHOW .)
    LESS_EQUAL      reduce using rule 85 (division_tail -> NO SHOW .)
    GREATER         reduce using rule 85 (division_tail -> NO SHOW .)
    GREATER_EQUAL   reduce using rule 85 (division_tail -> NO SHOW .)
    TO              reduce using rule 85 (division_tail -> NO SHOW .)
    DE              reduce using rule 85 (division_tail -> NO SHOW .)
    KARA            reduce using rule 85 (division_tail -> NO SHOW .)
    MADE            reduce using rule 85 (division_tail -> NO SHOW .)
    KO              reduce using rule 85 (division_tail -> NO SHOW .)
    R_C_BRACKET     reduce using rule 85 (division_tail -> NO SHOW .)


state 139

    (86) division_tail -> NO REMAINDER .

    WO              reduce using rule 86 (division_tail -> NO REMAINDER .)
    PLUS            reduce using rule 86 (division_tail -> NO REMAINDER .)
    MINUS           reduce using rule 86 (division_tail -> NO REMAINDER .)
    MULTI           reduce using rule 86 (division_tail -> NO REMAINDER .)
    ASTERISK        reduce using rule 86 (division_tail -> NO REMAINDER .)
    DIVID           reduce using rule 86 (division_tail -> NO REMAINDER .)
    SLASH           reduce using rule 86 (division_tail -> NO REMAINDER .)
    NO              reduce using rule 86 (division_tail -> NO REMAINDER .)
    RSHIFT          reduce using rule 86 (division_tail -> NO REMAINDER .)
    LSHIFT          reduce using rule 86 (division_tail -> NO REMAINDER .)
    CONJUNCT        reduce using rule 86 (division_tail -> NO REMAINDER .)
    LOGICSUM        reduce using rule 86 (division_tail -> NO REMAINDER .)
    R_PAREN         reduce using rule 86 (division_tail -> NO REMAINDER .)
    $end            reduce using rule 86 (division_tail -> NO REMAINDER .)
    R_S_BRACKET     reduce using rule 86 (division_tail -> NO REMAINDER .)
    COMMA           reduce using rule 86 (division_tail -> NO REMAINDER .)
    DIVREAL         reduce using rule 86 (division_tail -> NO REMAINDER .)
    GA              reduce using rule 86 (division_tail -> NO REMAINDER .)
    EQUAL           reduce using rule 86 (division_tail -> NO REMAINDER .)
    NOT             reduce using rule 86 (division_tail -> NO REMAINDER .)
    NOT2            reduce using rule 86 (division_tail -> NO REMAINDER .)
    LESS            reduce using rule 86 (division_tail -> NO REMAINDER .)
    LESS_EQUAL      reduce using rule 86 (division_tail -> NO REMAINDER .)
    GREATER         reduce using rule 86 (division_tail -> NO REMAINDER .)
    GREATER_EQUAL   reduce using rule 86 (division_tail -> NO REMAINDER .)
    TO              reduce using rule 86 (division_tail -> NO REMAINDER .)
    DE              reduce using rule 86 (division_tail -> NO REMAINDER .)
    KARA            reduce using rule 86 (division_tail -> NO REMAINDER .)
    MADE            reduce using rule 86 (division_tail -> NO REMAINDER .)
    KO              reduce using rule 86 (division_tail -> NO REMAINDER .)
    R_C_BRACKET     reduce using rule 86 (division_tail -> NO REMAINDER .)


state 140

    (89) value -> value NO DECIMAL_P BELOW WO . ROUNDED_UP VALUE

    ROUNDED_UP      shift and go to state 168


state 141

    (17) statement -> GLOBAL COLON TYPE ARRAY NO . ARRAY COLON NAME ASSIGN init_array2d

    ARRAY           shift and go to state 169


state 142

    (28) statement -> CIRCLE NAME L_PAREN params R_PAREN .

    $end            reduce using rule 28 (statement -> CIRCLE NAME L_PAREN params R_PAREN .)


state 143

    (23) params -> TYPE COLON . NAME params_m

    NAME            shift and go to state 170


state 144

    (24) params -> TYPE NO . ARRAY COLON NAME params_m

    ARRAY           shift and go to state 171


state 145

    (29) statement -> CIRCLE TYPE COLON NAME L_PAREN . params R_PAREN
    (22) params -> .
    (23) params -> . TYPE COLON NAME params_m
    (24) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 22 (params -> .)
    TYPE            shift and go to state 107

    params                         shift and go to state 172

state 146

    (30) statement -> CIRCLE TYPE NO ARRAY COLON . NAME L_PAREN params R_PAREN

    NAME            shift and go to state 173


state 147

    (78) value -> L_PAREN value R_PAREN NO RESULT .

    WO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    PLUS            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    MINUS           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    MULTI           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    ASTERISK        reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    DIVID           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    SLASH           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    NO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    RSHIFT          reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LSHIFT          reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    CONJUNCT        reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LOGICSUM        reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_PAREN         reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    $end            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_S_BRACKET     reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    COMMA           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    DIVREAL         reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    GA              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    EQUAL           reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    NOT             reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    NOT2            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LESS            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    LESS_EQUAL      reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    GREATER         reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    GREATER_EQUAL   reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    TO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    DE              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    KARA            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    MADE            reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    KO              reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_C_BRACKET     reduce using rule 78 (value -> L_PAREN value R_PAREN NO RESULT .)


state 148

    (90) value -> L_PAREN value R_PAREN NO DECIMAL_P . BELOW WO ROUNDED_UP VALUE

    BELOW           shift and go to state 174


state 149

    (72) value -> NAME L_S_BRACKET value R_S_BRACKET .
    (73) value -> NAME L_S_BRACKET value R_S_BRACKET . NO VALUE
    (74) value -> NAME L_S_BRACKET value R_S_BRACKET . L_S_BRACKET value R_S_BRACKET
    (76) value -> NAME L_S_BRACKET value R_S_BRACKET . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    R_PAREN         reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    ASTERISK        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    SLASH           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    RSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LSHIFT          reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    CONJUNCT        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LOGICSUM        reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    $end            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    WO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    R_S_BRACKET     reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    COMMA           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVREAL         reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GA              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    EQUAL           reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NOT             reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NOT2            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LESS            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LESS_EQUAL      reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GREATER         reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GREATER_EQUAL   reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    TO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DE              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    KARA            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MADE            reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    KO              reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    R_C_BRACKET     reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NO              shift and go to state 134
    L_S_BRACKET     shift and go to state 132

  ! NO              [ reduce using rule 72 (value -> NAME L_S_BRACKET value R_S_BRACKET .) ]


state 150

    (47) conditional -> value sign value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    R_PAREN         reduce using rule 47 (conditional -> value sign value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 151

    (57) conditional -> value GA value . TO HITOSHII
    (58) conditional -> value GA value . TO NOTHITOSHII
    (59) conditional -> value GA value . DE DIVISIBLE
    (60) conditional -> value GA value . TO value DE DIVISIBLE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    TO              shift and go to state 175
    DE              shift and go to state 176
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 152

    (49) sign -> NOT EQUAL .

    POW             reduce using rule 49 (sign -> NOT EQUAL .)
    NUMBER          reduce using rule 49 (sign -> NOT EQUAL .)
    MINUS           reduce using rule 49 (sign -> NOT EQUAL .)
    FLOAT           reduce using rule 49 (sign -> NOT EQUAL .)
    NAME            reduce using rule 49 (sign -> NOT EQUAL .)
    STRING          reduce using rule 49 (sign -> NOT EQUAL .)
    L_PAREN         reduce using rule 49 (sign -> NOT EQUAL .)


state 153

    (52) sign -> LESS EQUAL .

    POW             reduce using rule 52 (sign -> LESS EQUAL .)
    NUMBER          reduce using rule 52 (sign -> LESS EQUAL .)
    MINUS           reduce using rule 52 (sign -> LESS EQUAL .)
    FLOAT           reduce using rule 52 (sign -> LESS EQUAL .)
    NAME            reduce using rule 52 (sign -> LESS EQUAL .)
    STRING          reduce using rule 52 (sign -> LESS EQUAL .)
    L_PAREN         reduce using rule 52 (sign -> LESS EQUAL .)


state 154

    (55) sign -> GREATER EQUAL .

    POW             reduce using rule 55 (sign -> GREATER EQUAL .)
    NUMBER          reduce using rule 55 (sign -> GREATER EQUAL .)
    MINUS           reduce using rule 55 (sign -> GREATER EQUAL .)
    FLOAT           reduce using rule 55 (sign -> GREATER EQUAL .)
    NAME            reduce using rule 55 (sign -> GREATER EQUAL .)
    STRING          reduce using rule 55 (sign -> GREATER EQUAL .)
    L_PAREN         reduce using rule 55 (sign -> GREATER EQUAL .)


state 155

    (61) statement -> FOR L_PAREN NAME WO value . KARA value MADE NUMBER ZUTSU incdec R_PAREN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    KARA            shift and go to state 177
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 156

    (37) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 178
    value                          shift and go to state 63

state 157

    (4) decl_names_m -> COMMA NAME decl_names_m .

    $end            reduce using rule 4 (decl_names_m -> COMMA NAME decl_names_m .)


state 158

    (8) statement -> TYPE NO ARRAY COLON NAME ASSIGN . init_array
    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN . NAME L_PAREN args R_PAREN
    (9) init_array -> . L_C_BRACKET R_C_BRACKET
    (10) init_array -> . L_C_BRACKET init_array_val R_C_BRACKET
    (13) init_array -> . L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET

    NAME            shift and go to state 179
    L_C_BRACKET     shift and go to state 181

    init_array                     shift and go to state 180

state 159

    (16) statement -> TYPE ARRAY NO ARRAY COLON NAME . ASSIGN init_array2d

    ASSIGN          shift and go to state 182


state 160

    (36) statement -> NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 36 (statement -> NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 161

    (74) value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value . R_S_BRACKET
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    R_S_BRACKET     shift and go to state 183
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 162

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    $end            reduce using rule 14 (statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 163

    (73) value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .

    WO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    PLUS            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MINUS           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MULTI           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    ASTERISK        reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DIVID           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    SLASH           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    RSHIFT          reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LSHIFT          reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    CONJUNCT        reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LOGICSUM        reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_PAREN         reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    $end            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_S_BRACKET     reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    COMMA           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DIVREAL         reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GA              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    EQUAL           reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NOT             reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NOT2            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LESS            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LESS_EQUAL      reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GREATER         reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GREATER_EQUAL   reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    TO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DE              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    KARA            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MADE            reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    KO              reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_C_BRACKET     reduce using rule 73 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)


state 164

    (76) value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .

    WO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    PLUS            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    MINUS           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    MULTI           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    ASTERISK        reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    DIVID           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    SLASH           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    NO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    RSHIFT          reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LSHIFT          reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    CONJUNCT        reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LOGICSUM        reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    R_PAREN         reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    $end            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    R_S_BRACKET     reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    COMMA           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    DIVREAL         reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    GA              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    EQUAL           reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    NOT             reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    NOT2            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LESS            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    LESS_EQUAL      reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    GREATER         reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    GREATER_EQUAL   reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    TO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    DE              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    KARA            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    MADE            reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    KO              reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)
    R_C_BRACKET     reduce using rule 76 (value -> NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN .)


state 165

    (39) statement -> NAME NO END NI NAME L_PAREN . args R_PAREN NO RETURN_VAL WO ADD
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 184
    value                          shift and go to state 63

state 166

    (15) statement -> NAME NO END NI value WO . ADD

    ADD             shift and go to state 185


state 167

    (33) args_m -> COMMA value args_m .

    R_PAREN         reduce using rule 33 (args_m -> COMMA value args_m .)


state 168

    (89) value -> value NO DECIMAL_P BELOW WO ROUNDED_UP . VALUE

    VALUE           shift and go to state 186


state 169

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY . COLON NAME ASSIGN init_array2d

    COLON           shift and go to state 187


state 170

    (23) params -> TYPE COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 189
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 188

state 171

    (24) params -> TYPE NO ARRAY . COLON NAME params_m

    COLON           shift and go to state 190


state 172

    (29) statement -> CIRCLE TYPE COLON NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 191


state 173

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 192


state 174

    (90) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW . WO ROUNDED_UP VALUE

    WO              shift and go to state 193


state 175

    (57) conditional -> value GA value TO . HITOSHII
    (58) conditional -> value GA value TO . NOTHITOSHII
    (60) conditional -> value GA value TO . value DE DIVISIBLE
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    HITOSHII        shift and go to state 195
    NOTHITOSHII     shift and go to state 196
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 194

state 176

    (59) conditional -> value GA value DE . DIVISIBLE

    DIVISIBLE       shift and go to state 197


state 177

    (61) statement -> FOR L_PAREN NAME WO value KARA . value MADE NUMBER ZUTSU incdec R_PAREN
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 198

state 178

    (37) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 199


state 179

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME . L_PAREN args R_PAREN

    L_PAREN         shift and go to state 200


state 180

    (8) statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array .

    $end            reduce using rule 8 (statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array .)


state 181

    (9) init_array -> L_C_BRACKET . R_C_BRACKET
    (10) init_array -> L_C_BRACKET . init_array_val R_C_BRACKET
    (13) init_array -> L_C_BRACKET . value KO NO UNDEF NO VALUE R_C_BRACKET
    (11) init_array_val -> . init_array_val COMMA value
    (12) init_array_val -> . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    R_C_BRACKET     shift and go to state 201
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    init_array_val                 shift and go to state 202
    value                          shift and go to state 203

state 182

    (16) statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN . init_array2d
    (18) init_array2d -> . L_C_BRACKET init_array2d_val R_C_BRACKET

    L_C_BRACKET     shift and go to state 205

    init_array2d                   shift and go to state 204

state 183

    (74) value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .

    WO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    ASTERISK        reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    SLASH           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    NO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    RSHIFT          reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LSHIFT          reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    CONJUNCT        reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LOGICSUM        reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    R_PAREN         reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    $end            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    R_S_BRACKET     reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    COMMA           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    DIVREAL         reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    GA              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    EQUAL           reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    NOT             reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    NOT2            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LESS            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    LESS_EQUAL      reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    GREATER         reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    GREATER_EQUAL   reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    TO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    DE              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    KARA            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    MADE            reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    KO              reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)
    R_C_BRACKET     reduce using rule 74 (value -> NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET .)


state 184

    (39) statement -> NAME NO END NI NAME L_PAREN args . R_PAREN NO RETURN_VAL WO ADD

    R_PAREN         shift and go to state 206


state 185

    (15) statement -> NAME NO END NI value WO ADD .

    $end            reduce using rule 15 (statement -> NAME NO END NI value WO ADD .)


state 186

    (89) value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .

    WO              reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    PLUS            reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MINUS           reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MULTI           reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    ASTERISK        reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVID           reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    SLASH           reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NO              reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    RSHIFT          reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LSHIFT          reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    CONJUNCT        reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LOGICSUM        reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_PAREN         reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    $end            reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_S_BRACKET     reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    COMMA           reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVREAL         reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GA              reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    EQUAL           reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT             reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT2            reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS            reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS_EQUAL      reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER         reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER_EQUAL   reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    TO              reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DE              reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KARA            reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MADE            reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KO              reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_C_BRACKET     reduce using rule 89 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)


state 187

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON . NAME ASSIGN init_array2d

    NAME            shift and go to state 207


state 188

    (23) params -> TYPE COLON NAME params_m .

    R_PAREN         reduce using rule 23 (params -> TYPE COLON NAME params_m .)


state 189

    (25) params_m -> COMMA . TYPE COLON NAME params_m
    (26) params_m -> COMMA . TYPE NO ARRAY COLON NAME params_m

    TYPE            shift and go to state 208


state 190

    (24) params -> TYPE NO ARRAY COLON . NAME params_m

    NAME            shift and go to state 209


state 191

    (29) statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN .

    $end            reduce using rule 29 (statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN .)


state 192

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN . params R_PAREN
    (22) params -> .
    (23) params -> . TYPE COLON NAME params_m
    (24) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 22 (params -> .)
    TYPE            shift and go to state 107

    params                         shift and go to state 210

state 193

    (90) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO . ROUNDED_UP VALUE

    ROUNDED_UP      shift and go to state 211


state 194

    (60) conditional -> value GA value TO value . DE DIVISIBLE
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    DE              shift and go to state 212
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 195

    (57) conditional -> value GA value TO HITOSHII .

    R_PAREN         reduce using rule 57 (conditional -> value GA value TO HITOSHII .)


state 196

    (58) conditional -> value GA value TO NOTHITOSHII .

    R_PAREN         reduce using rule 58 (conditional -> value GA value TO NOTHITOSHII .)


state 197

    (59) conditional -> value GA value DE DIVISIBLE .

    R_PAREN         reduce using rule 59 (conditional -> value GA value DE DIVISIBLE .)


state 198

    (61) statement -> FOR L_PAREN NAME WO value KARA value . MADE NUMBER ZUTSU incdec R_PAREN
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    MADE            shift and go to state 213
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 199

    (37) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 37 (statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 200

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN . args R_PAREN
    (31) args -> .
    (32) args -> . value args_m
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    R_PAREN         reduce using rule 31 (args -> .)
    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    args                           shift and go to state 214
    value                          shift and go to state 63

state 201

    (9) init_array -> L_C_BRACKET R_C_BRACKET .

    $end            reduce using rule 9 (init_array -> L_C_BRACKET R_C_BRACKET .)
    R_C_BRACKET     reduce using rule 9 (init_array -> L_C_BRACKET R_C_BRACKET .)
    COMMA           reduce using rule 9 (init_array -> L_C_BRACKET R_C_BRACKET .)


state 202

    (10) init_array -> L_C_BRACKET init_array_val . R_C_BRACKET
    (11) init_array_val -> init_array_val . COMMA value

    R_C_BRACKET     shift and go to state 215
    COMMA           shift and go to state 216


state 203

    (13) init_array -> L_C_BRACKET value . KO NO UNDEF NO VALUE R_C_BRACKET
    (12) init_array_val -> value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    KO              shift and go to state 217
    R_C_BRACKET     reduce using rule 12 (init_array_val -> value .)
    COMMA           reduce using rule 12 (init_array_val -> value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 204

    (16) statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .

    $end            reduce using rule 16 (statement -> TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .)


state 205

    (18) init_array2d -> L_C_BRACKET . init_array2d_val R_C_BRACKET
    (19) init_array2d_val -> . init_array2d_val COMMA init_array
    (20) init_array2d_val -> . init_array
    (9) init_array -> . L_C_BRACKET R_C_BRACKET
    (10) init_array -> . L_C_BRACKET init_array_val R_C_BRACKET
    (13) init_array -> . L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET

    L_C_BRACKET     shift and go to state 181

    init_array2d_val               shift and go to state 218
    init_array                     shift and go to state 219

state 206

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN . NO RETURN_VAL WO ADD

    NO              shift and go to state 220


state 207

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME . ASSIGN init_array2d

    ASSIGN          shift and go to state 221


state 208

    (25) params_m -> COMMA TYPE . COLON NAME params_m
    (26) params_m -> COMMA TYPE . NO ARRAY COLON NAME params_m

    COLON           shift and go to state 222
    NO              shift and go to state 223


state 209

    (24) params -> TYPE NO ARRAY COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 189
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 224

state 210

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 225


state 211

    (90) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP . VALUE

    VALUE           shift and go to state 226


state 212

    (60) conditional -> value GA value TO value DE . DIVISIBLE

    DIVISIBLE       shift and go to state 227


state 213

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE . NUMBER ZUTSU incdec R_PAREN

    NUMBER          shift and go to state 228


state 214

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 229


state 215

    (10) init_array -> L_C_BRACKET init_array_val R_C_BRACKET .

    $end            reduce using rule 10 (init_array -> L_C_BRACKET init_array_val R_C_BRACKET .)
    R_C_BRACKET     reduce using rule 10 (init_array -> L_C_BRACKET init_array_val R_C_BRACKET .)
    COMMA           reduce using rule 10 (init_array -> L_C_BRACKET init_array_val R_C_BRACKET .)


state 216

    (11) init_array_val -> init_array_val COMMA . value
    (40) value -> . POW L_PAREN args R_PAREN
    (67) value -> . NUMBER
    (68) value -> . MINUS value
    (69) value -> . FLOAT
    (70) value -> . NAME
    (71) value -> . STRING
    (72) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (73) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (74) value -> . NAME L_S_BRACKET value R_S_BRACKET L_S_BRACKET value R_S_BRACKET
    (75) value -> . NAME NO ARR_LEN
    (76) value -> . NAME L_S_BRACKET value R_S_BRACKET NO ARR_LEN
    (77) value -> . L_PAREN value R_PAREN
    (78) value -> . L_PAREN value R_PAREN NO RESULT
    (79) value -> . value PLUS value
    (80) value -> . value MINUS value
    (81) value -> . value MULTI value
    (82) value -> . value ASTERISK value
    (83) value -> . value DIVID value division_tail
    (84) value -> . value SLASH value division_tail
    (89) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (90) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> . value RSHIFT value
    (92) value -> . value LSHIFT value
    (93) value -> . value CONJUNCT value
    (94) value -> . value LOGICSUM value

    POW             shift and go to state 18
    NUMBER          shift and go to state 14
    MINUS           shift and go to state 19
    FLOAT           shift and go to state 20
    NAME            shift and go to state 45
    STRING          shift and go to state 21
    L_PAREN         shift and go to state 7

    value                          shift and go to state 230

state 217

    (13) init_array -> L_C_BRACKET value KO . NO UNDEF NO VALUE R_C_BRACKET

    NO              shift and go to state 231


state 218

    (18) init_array2d -> L_C_BRACKET init_array2d_val . R_C_BRACKET
    (19) init_array2d_val -> init_array2d_val . COMMA init_array

    R_C_BRACKET     shift and go to state 232
    COMMA           shift and go to state 233


state 219

    (20) init_array2d_val -> init_array .

    R_C_BRACKET     reduce using rule 20 (init_array2d_val -> init_array .)
    COMMA           reduce using rule 20 (init_array2d_val -> init_array .)


state 220

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO . RETURN_VAL WO ADD

    RETURN_VAL      shift and go to state 234


state 221

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN . init_array2d
    (18) init_array2d -> . L_C_BRACKET init_array2d_val R_C_BRACKET

    L_C_BRACKET     shift and go to state 205

    init_array2d                   shift and go to state 235

state 222

    (25) params_m -> COMMA TYPE COLON . NAME params_m

    NAME            shift and go to state 236


state 223

    (26) params_m -> COMMA TYPE NO . ARRAY COLON NAME params_m

    ARRAY           shift and go to state 237


state 224

    (24) params -> TYPE NO ARRAY COLON NAME params_m .

    R_PAREN         reduce using rule 24 (params -> TYPE NO ARRAY COLON NAME params_m .)


state 225

    (30) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN .

    $end            reduce using rule 30 (statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN .)


state 226

    (90) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .

    WO              reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    PLUS            reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MINUS           reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MULTI           reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    ASTERISK        reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVID           reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    SLASH           reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NO              reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    RSHIFT          reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LSHIFT          reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    CONJUNCT        reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LOGICSUM        reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_PAREN         reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    $end            reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_S_BRACKET     reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    COMMA           reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVREAL         reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GA              reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    EQUAL           reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT             reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT2            reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS            reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS_EQUAL      reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER         reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER_EQUAL   reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    TO              reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DE              reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KARA            reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MADE            reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KO              reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_C_BRACKET     reduce using rule 90 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)


state 227

    (60) conditional -> value GA value TO value DE DIVISIBLE .

    R_PAREN         reduce using rule 60 (conditional -> value GA value TO value DE DIVISIBLE .)


state 228

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER . ZUTSU incdec R_PAREN

    ZUTSU           shift and go to state 238


state 229

    (38) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 38 (statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 230

    (11) init_array_val -> init_array_val COMMA value .
    (79) value -> value . PLUS value
    (80) value -> value . MINUS value
    (81) value -> value . MULTI value
    (82) value -> value . ASTERISK value
    (83) value -> value . DIVID value division_tail
    (84) value -> value . SLASH value division_tail
    (89) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (91) value -> value . RSHIFT value
    (92) value -> value . LSHIFT value
    (93) value -> value . CONJUNCT value
    (94) value -> value . LOGICSUM value

    R_C_BRACKET     reduce using rule 11 (init_array_val -> init_array_val COMMA value .)
    COMMA           reduce using rule 11 (init_array_val -> init_array_val COMMA value .)
    PLUS            shift and go to state 30
    MINUS           shift and go to state 31
    MULTI           shift and go to state 32
    ASTERISK        shift and go to state 33
    DIVID           shift and go to state 34
    SLASH           shift and go to state 35
    NO              shift and go to state 36
    RSHIFT          shift and go to state 37
    LSHIFT          shift and go to state 38
    CONJUNCT        shift and go to state 39
    LOGICSUM        shift and go to state 40


state 231

    (13) init_array -> L_C_BRACKET value KO NO . UNDEF NO VALUE R_C_BRACKET

    UNDEF           shift and go to state 239


state 232

    (18) init_array2d -> L_C_BRACKET init_array2d_val R_C_BRACKET .

    $end            reduce using rule 18 (init_array2d -> L_C_BRACKET init_array2d_val R_C_BRACKET .)


state 233

    (19) init_array2d_val -> init_array2d_val COMMA . init_array
    (9) init_array -> . L_C_BRACKET R_C_BRACKET
    (10) init_array -> . L_C_BRACKET init_array_val R_C_BRACKET
    (13) init_array -> . L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET

    L_C_BRACKET     shift and go to state 181

    init_array                     shift and go to state 240

state 234

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL . WO ADD

    WO              shift and go to state 241


state 235

    (17) statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .

    $end            reduce using rule 17 (statement -> GLOBAL COLON TYPE ARRAY NO ARRAY COLON NAME ASSIGN init_array2d .)


state 236

    (25) params_m -> COMMA TYPE COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 189
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 242

state 237

    (26) params_m -> COMMA TYPE NO ARRAY . COLON NAME params_m

    COLON           shift and go to state 243


state 238

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU . incdec R_PAREN
    (62) incdec -> . INCREASE
    (63) incdec -> . DECREASE

    INCREASE        shift and go to state 245
    DECREASE        shift and go to state 246

    incdec                         shift and go to state 244

state 239

    (13) init_array -> L_C_BRACKET value KO NO UNDEF . NO VALUE R_C_BRACKET

    NO              shift and go to state 247


state 240

    (19) init_array2d_val -> init_array2d_val COMMA init_array .

    R_C_BRACKET     reduce using rule 19 (init_array2d_val -> init_array2d_val COMMA init_array .)
    COMMA           reduce using rule 19 (init_array2d_val -> init_array2d_val COMMA init_array .)


state 241

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO . ADD

    ADD             shift and go to state 248


state 242

    (25) params_m -> COMMA TYPE COLON NAME params_m .

    R_PAREN         reduce using rule 25 (params_m -> COMMA TYPE COLON NAME params_m .)


state 243

    (26) params_m -> COMMA TYPE NO ARRAY COLON . NAME params_m

    NAME            shift and go to state 249


state 244

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec . R_PAREN

    R_PAREN         shift and go to state 250


state 245

    (62) incdec -> INCREASE .

    R_PAREN         reduce using rule 62 (incdec -> INCREASE .)


state 246

    (63) incdec -> DECREASE .

    R_PAREN         reduce using rule 63 (incdec -> DECREASE .)


state 247

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO . VALUE R_C_BRACKET

    VALUE           shift and go to state 251


state 248

    (39) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD .

    $end            reduce using rule 39 (statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD .)


state 249

    (26) params_m -> COMMA TYPE NO ARRAY COLON NAME . params_m
    (25) params_m -> . COMMA TYPE COLON NAME params_m
    (26) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (27) params_m -> .

    COMMA           shift and go to state 189
    R_PAREN         reduce using rule 27 (params_m -> .)

    params_m                       shift and go to state 252

state 250

    (61) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN .

    $end            reduce using rule 61 (statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU incdec R_PAREN .)


state 251

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE . R_C_BRACKET

    R_C_BRACKET     shift and go to state 253


state 252

    (26) params_m -> COMMA TYPE NO ARRAY COLON NAME params_m .

    R_PAREN         reduce using rule 26 (params_m -> COMMA TYPE NO ARRAY COLON NAME params_m .)


state 253

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .

    $end            reduce using rule 13 (init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .)
    R_C_BRACKET     reduce using rule 13 (init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .)
    COMMA           reduce using rule 13 (init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NO in state 3 resolved as shift
WARNING: shift/reduce conflict for NO in state 45 resolved as shift
WARNING: shift/reduce conflict for NO in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 68 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 68 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 68 resolved as shift
WARNING: shift/reduce conflict for SLASH in state 68 resolved as shift
WARNING: shift/reduce conflict for NO in state 68 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 68 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 68 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 68 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 69 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 69 resolved as shift
WARNING: shift/reduce conflict for SLASH in state 69 resolved as shift
WARNING: shift/reduce conflict for NO in state 69 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 69 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 69 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 69 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVREAL in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 70 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 70 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 70 resolved as shift
WARNING: shift/reduce conflict for SLASH in state 70 resolved as shift
WARNING: shift/reduce conflict for NO in state 70 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 70 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 70 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 70 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 70 resolved as shift
WARNING: shift/reduce conflict for DIVREAL in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 74 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 74 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 74 resolved as shift
WARNING: shift/reduce conflict for SLASH in state 74 resolved as shift
WARNING: shift/reduce conflict for NO in state 74 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 74 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 74 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 74 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 74 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 75 resolved as shift
WARNING: shift/reduce conflict for ASTERISK in state 75 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 75 resolved as shift
WARNING: shift/reduce conflict for SLASH in state 75 resolved as shift
WARNING: shift/reduce conflict for NO in state 75 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 75 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 75 resolved as shift
WARNING: shift/reduce conflict for CONJUNCT in state 75 resolved as shift
WARNING: shift/reduce conflict for LOGICSUM in state 75 resolved as shift
WARNING: shift/reduce conflict for NO in state 80 resolved as shift
WARNING: shift/reduce conflict for NO in state 95 resolved as shift
WARNING: shift/reduce conflict for NO in state 126 resolved as shift
WARNING: shift/reduce conflict for NO in state 135 resolved as shift
WARNING: shift/reduce conflict for NO in state 149 resolved as shift
