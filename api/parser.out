Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    INDIVISIBLE

Grammar

Rule 0     S' -> statement
Rule 1     statement -> <empty>
Rule 2     statement -> TYPE COLON decl_names
Rule 3     decl_names -> NAME decl_names_m
Rule 4     decl_names_m -> COMMA NAME decl_names_m
Rule 5     decl_names_m -> <empty>
Rule 6     statement -> TYPE COLON NAME ASSIGN value
Rule 7     statement -> NAME ASSIGN value
Rule 8     statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array
Rule 9     init_array -> L_C_BRACKET R_C_BRACKET
Rule 10    init_array -> L_C_BRACKET init_array_val R_C_BRACKET
Rule 11    init_array_val -> init_array_val COMMA value
Rule 12    init_array_val -> value
Rule 13    init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET
Rule 14    statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value
Rule 15    statement -> NAME NO END NI value WO ADD
Rule 16    statement -> value WO OUT
Rule 17    params -> <empty>
Rule 18    params -> TYPE COLON NAME params_m
Rule 19    params -> TYPE NO ARRAY COLON NAME params_m
Rule 20    params_m -> COMMA TYPE COLON NAME params_m
Rule 21    params_m -> COMMA TYPE NO ARRAY COLON NAME params_m
Rule 22    params_m -> <empty>
Rule 23    statement -> CIRCLE NAME L_PAREN params R_PAREN
Rule 24    statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN
Rule 25    statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN
Rule 26    args -> <empty>
Rule 27    args -> value args_m
Rule 28    args_m -> COMMA value args_m
Rule 29    args_m -> <empty>
Rule 30    statement -> NAME L_PAREN args R_PAREN
Rule 31    statement -> NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 32    statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 33    statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN
Rule 34    statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
Rule 35    value -> POW L_PAREN args R_PAREN
Rule 36    statement -> RETURN
Rule 37    statement -> RETURN value
Rule 38    statement -> IF L_PAREN conditional R_PAREN
Rule 39    statement -> ELSEIF L_PAREN conditional R_PAREN
Rule 40    statement -> ELSE
Rule 41    statement -> ENDIF
Rule 42    conditional -> value sign value
Rule 43    sign -> EQUAL
Rule 44    sign -> NOT EQUAL
Rule 45    sign -> NOT2
Rule 46    sign -> LESS
Rule 47    sign -> LESS EQUAL
Rule 48    sign -> LESS_EQUAL
Rule 49    sign -> GREATER
Rule 50    sign -> GREATER EQUAL
Rule 51    sign -> GREATER_EQUAL
Rule 52    conditional -> value GA value DE DIVISIBLE
Rule 53    conditional -> value GA value TO value DE DIVISIBLE
Rule 54    statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN
Rule 55    statement -> ENDFOR
Rule 56    statement -> WHILE L_PAREN conditional R_PAREN
Rule 57    statement -> DO
Rule 58    value -> NUMBER
Rule 59    value -> FLOAT
Rule 60    value -> NAME
Rule 61    value -> STRING
Rule 62    value -> NAME L_S_BRACKET value R_S_BRACKET
Rule 63    value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE
Rule 64    value -> NAME NO ARR_LEN
Rule 65    value -> L_PAREN value R_PAREN
Rule 66    value -> L_PAREN value R_PAREN NO RESULT
Rule 67    value -> value PLUS value
Rule 68    value -> value MINUS value
Rule 69    value -> value MULTI value
Rule 70    value -> value DIVID value division_tail
Rule 71    division_tail -> NO SHOW
Rule 72    division_tail -> <empty>
Rule 73    value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
Rule 74    value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

Terminals, with rules where they appear

ADD                  : 15 34
ARRAY                : 8 19 21 25 33
ARR_LEN              : 64
ASSIGN               : 6 7 8 14 31 32 33
BELOW                : 73 74
CIRCLE               : 23 24 25
COLON                : 2 6 8 18 19 20 21 24 25 32 33
COMMA                : 4 11 20 21 28
DE                   : 52 53
DECIMAL_P            : 73 74
DIVID                : 70
DIVISIBLE            : 52 53
DO                   : 57
ELSE                 : 40
ELSEIF               : 39
END                  : 15 34
ENDFOR               : 55
ENDIF                : 41
EQUAL                : 43 44 47 50
FLOAT                : 59
FOR                  : 54
GA                   : 52 53
GREATER              : 49 50
GREATER_EQUAL        : 51
IF                   : 38
INCREASE             : 54
INDIVISIBLE          : 
KARA                 : 54
KO                   : 13
LESS                 : 46 47
LESS_EQUAL           : 48
L_C_BRACKET          : 9 10 13
L_PAREN              : 23 24 25 30 31 32 33 34 35 38 39 54 56 65 66 74
L_S_BRACKET          : 14 62 63
MADE                 : 54
MINUS                : 68
MULTI                : 69
NAME                 : 3 4 6 7 8 14 15 18 19 20 21 23 24 25 30 31 31 32 32 33 33 34 34 54 60 62 63 64
NI                   : 15 34
NO                   : 8 13 13 15 19 21 25 33 34 34 63 64 66 71 73 74
NOT                  : 44
NOT2                 : 45
NUMBER               : 54 58
OUT                  : 16
PLUS                 : 67
POW                  : 35
RESULT               : 66
RETURN               : 36 37
RETURN_VAL           : 34
ROUNDED_UP           : 73 74
R_C_BRACKET          : 9 10 13
R_PAREN              : 23 24 25 30 31 32 33 34 35 38 39 54 56 65 66 74
R_S_BRACKET          : 14 62 63
SHOW                 : 71
STRING               : 61
TO                   : 53
TYPE                 : 2 6 8 18 19 20 21 24 25 32 33
UNDEF                : 13
VALUE                : 13 63 73 74
WHILE                : 56
WO                   : 15 16 34 54 73 74
ZUTSU                : 54
error                : 

Nonterminals, with rules where they appear

args                 : 30 31 32 33 34 35
args_m               : 27 28
conditional          : 38 39 56
decl_names           : 2
decl_names_m         : 3 4
division_tail        : 70
init_array           : 8
init_array_val       : 10 11
params               : 23 24 25
params_m             : 18 19 20 21
sign                 : 42
statement            : 0
value                : 6 7 11 12 13 14 14 15 16 27 28 37 42 42 52 52 53 53 53 54 54 62 63 65 66 67 67 68 68 69 69 70 70 73 74

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> .
    (2) statement -> . TYPE COLON decl_names
    (6) statement -> . TYPE COLON NAME ASSIGN value
    (7) statement -> . NAME ASSIGN value
    (8) statement -> . TYPE NO ARRAY COLON NAME ASSIGN init_array
    (14) statement -> . NAME L_S_BRACKET value R_S_BRACKET ASSIGN value
    (15) statement -> . NAME NO END NI value WO ADD
    (16) statement -> . value WO OUT
    (23) statement -> . CIRCLE NAME L_PAREN params R_PAREN
    (24) statement -> . CIRCLE TYPE COLON NAME L_PAREN params R_PAREN
    (25) statement -> . CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN
    (30) statement -> . NAME L_PAREN args R_PAREN
    (31) statement -> . NAME ASSIGN NAME L_PAREN args R_PAREN
    (32) statement -> . TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (33) statement -> . TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (34) statement -> . NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (36) statement -> . RETURN
    (37) statement -> . RETURN value
    (38) statement -> . IF L_PAREN conditional R_PAREN
    (39) statement -> . ELSEIF L_PAREN conditional R_PAREN
    (40) statement -> . ELSE
    (41) statement -> . ENDIF
    (54) statement -> . FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN
    (55) statement -> . ENDFOR
    (56) statement -> . WHILE L_PAREN conditional R_PAREN
    (57) statement -> . DO
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    $end            reduce using rule 1 (statement -> .)
    TYPE            shift and go to state 2
    NAME            shift and go to state 3
    CIRCLE          shift and go to state 5
    RETURN          shift and go to state 7
    IF              shift and go to state 8
    ELSEIF          shift and go to state 9
    ELSE            shift and go to state 10
    ENDIF           shift and go to state 11
    FOR             shift and go to state 12
    ENDFOR          shift and go to state 14
    WHILE           shift and go to state 15
    DO              shift and go to state 16
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    statement                      shift and go to state 1
    value                          shift and go to state 4

state 1

    (0) S' -> statement .



state 2

    (2) statement -> TYPE . COLON decl_names
    (6) statement -> TYPE . COLON NAME ASSIGN value
    (8) statement -> TYPE . NO ARRAY COLON NAME ASSIGN init_array
    (32) statement -> TYPE . COLON NAME ASSIGN NAME L_PAREN args R_PAREN
    (33) statement -> TYPE . NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    COLON           shift and go to state 20
    NO              shift and go to state 21


state 3

    (7) statement -> NAME . ASSIGN value
    (14) statement -> NAME . L_S_BRACKET value R_S_BRACKET ASSIGN value
    (15) statement -> NAME . NO END NI value WO ADD
    (30) statement -> NAME . L_PAREN args R_PAREN
    (31) statement -> NAME . ASSIGN NAME L_PAREN args R_PAREN
    (34) statement -> NAME . NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (60) value -> NAME .
    (62) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (63) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> NAME . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    ASSIGN          shift and go to state 22
    L_S_BRACKET     shift and go to state 23
    NO              shift and go to state 24
    L_PAREN         shift and go to state 25
    WO              reduce using rule 60 (value -> NAME .)
    PLUS            reduce using rule 60 (value -> NAME .)
    MINUS           reduce using rule 60 (value -> NAME .)
    MULTI           reduce using rule 60 (value -> NAME .)
    DIVID           reduce using rule 60 (value -> NAME .)

  ! NO              [ reduce using rule 60 (value -> NAME .) ]


state 4

    (16) statement -> value . WO OUT
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    WO              shift and go to state 26
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 5

    (23) statement -> CIRCLE . NAME L_PAREN params R_PAREN
    (24) statement -> CIRCLE . TYPE COLON NAME L_PAREN params R_PAREN
    (25) statement -> CIRCLE . TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN

    NAME            shift and go to state 32
    TYPE            shift and go to state 33


state 6

    (65) value -> L_PAREN . value R_PAREN
    (66) value -> L_PAREN . value R_PAREN NO RESULT
    (74) value -> L_PAREN . value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 34

state 7

    (36) statement -> RETURN .
    (37) statement -> RETURN . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    $end            reduce using rule 36 (statement -> RETURN .)
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 36

state 8

    (38) statement -> IF . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 37


state 9

    (39) statement -> ELSEIF . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 38


state 10

    (40) statement -> ELSE .

    $end            reduce using rule 40 (statement -> ELSE .)


state 11

    (41) statement -> ENDIF .

    $end            reduce using rule 41 (statement -> ENDIF .)


state 12

    (54) statement -> FOR . L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN

    L_PAREN         shift and go to state 39


state 13

    (58) value -> NUMBER .

    WO              reduce using rule 58 (value -> NUMBER .)
    PLUS            reduce using rule 58 (value -> NUMBER .)
    MINUS           reduce using rule 58 (value -> NUMBER .)
    MULTI           reduce using rule 58 (value -> NUMBER .)
    DIVID           reduce using rule 58 (value -> NUMBER .)
    NO              reduce using rule 58 (value -> NUMBER .)
    R_PAREN         reduce using rule 58 (value -> NUMBER .)
    $end            reduce using rule 58 (value -> NUMBER .)
    R_S_BRACKET     reduce using rule 58 (value -> NUMBER .)
    COMMA           reduce using rule 58 (value -> NUMBER .)
    GA              reduce using rule 58 (value -> NUMBER .)
    EQUAL           reduce using rule 58 (value -> NUMBER .)
    NOT             reduce using rule 58 (value -> NUMBER .)
    NOT2            reduce using rule 58 (value -> NUMBER .)
    LESS            reduce using rule 58 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 58 (value -> NUMBER .)
    GREATER         reduce using rule 58 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 58 (value -> NUMBER .)
    DE              reduce using rule 58 (value -> NUMBER .)
    TO              reduce using rule 58 (value -> NUMBER .)
    KARA            reduce using rule 58 (value -> NUMBER .)
    MADE            reduce using rule 58 (value -> NUMBER .)
    KO              reduce using rule 58 (value -> NUMBER .)
    R_C_BRACKET     reduce using rule 58 (value -> NUMBER .)


state 14

    (55) statement -> ENDFOR .

    $end            reduce using rule 55 (statement -> ENDFOR .)


state 15

    (56) statement -> WHILE . L_PAREN conditional R_PAREN

    L_PAREN         shift and go to state 40


state 16

    (57) statement -> DO .

    $end            reduce using rule 57 (statement -> DO .)


state 17

    (35) value -> POW . L_PAREN args R_PAREN

    L_PAREN         shift and go to state 41


state 18

    (59) value -> FLOAT .

    WO              reduce using rule 59 (value -> FLOAT .)
    PLUS            reduce using rule 59 (value -> FLOAT .)
    MINUS           reduce using rule 59 (value -> FLOAT .)
    MULTI           reduce using rule 59 (value -> FLOAT .)
    DIVID           reduce using rule 59 (value -> FLOAT .)
    NO              reduce using rule 59 (value -> FLOAT .)
    R_PAREN         reduce using rule 59 (value -> FLOAT .)
    $end            reduce using rule 59 (value -> FLOAT .)
    R_S_BRACKET     reduce using rule 59 (value -> FLOAT .)
    COMMA           reduce using rule 59 (value -> FLOAT .)
    GA              reduce using rule 59 (value -> FLOAT .)
    EQUAL           reduce using rule 59 (value -> FLOAT .)
    NOT             reduce using rule 59 (value -> FLOAT .)
    NOT2            reduce using rule 59 (value -> FLOAT .)
    LESS            reduce using rule 59 (value -> FLOAT .)
    LESS_EQUAL      reduce using rule 59 (value -> FLOAT .)
    GREATER         reduce using rule 59 (value -> FLOAT .)
    GREATER_EQUAL   reduce using rule 59 (value -> FLOAT .)
    DE              reduce using rule 59 (value -> FLOAT .)
    TO              reduce using rule 59 (value -> FLOAT .)
    KARA            reduce using rule 59 (value -> FLOAT .)
    MADE            reduce using rule 59 (value -> FLOAT .)
    KO              reduce using rule 59 (value -> FLOAT .)
    R_C_BRACKET     reduce using rule 59 (value -> FLOAT .)


state 19

    (61) value -> STRING .

    WO              reduce using rule 61 (value -> STRING .)
    PLUS            reduce using rule 61 (value -> STRING .)
    MINUS           reduce using rule 61 (value -> STRING .)
    MULTI           reduce using rule 61 (value -> STRING .)
    DIVID           reduce using rule 61 (value -> STRING .)
    NO              reduce using rule 61 (value -> STRING .)
    R_PAREN         reduce using rule 61 (value -> STRING .)
    $end            reduce using rule 61 (value -> STRING .)
    R_S_BRACKET     reduce using rule 61 (value -> STRING .)
    COMMA           reduce using rule 61 (value -> STRING .)
    GA              reduce using rule 61 (value -> STRING .)
    EQUAL           reduce using rule 61 (value -> STRING .)
    NOT             reduce using rule 61 (value -> STRING .)
    NOT2            reduce using rule 61 (value -> STRING .)
    LESS            reduce using rule 61 (value -> STRING .)
    LESS_EQUAL      reduce using rule 61 (value -> STRING .)
    GREATER         reduce using rule 61 (value -> STRING .)
    GREATER_EQUAL   reduce using rule 61 (value -> STRING .)
    DE              reduce using rule 61 (value -> STRING .)
    TO              reduce using rule 61 (value -> STRING .)
    KARA            reduce using rule 61 (value -> STRING .)
    MADE            reduce using rule 61 (value -> STRING .)
    KO              reduce using rule 61 (value -> STRING .)
    R_C_BRACKET     reduce using rule 61 (value -> STRING .)


state 20

    (2) statement -> TYPE COLON . decl_names
    (6) statement -> TYPE COLON . NAME ASSIGN value
    (32) statement -> TYPE COLON . NAME ASSIGN NAME L_PAREN args R_PAREN
    (3) decl_names -> . NAME decl_names_m

    NAME            shift and go to state 43

    decl_names                     shift and go to state 42

state 21

    (8) statement -> TYPE NO . ARRAY COLON NAME ASSIGN init_array
    (33) statement -> TYPE NO . ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    ARRAY           shift and go to state 44


state 22

    (7) statement -> NAME ASSIGN . value
    (31) statement -> NAME ASSIGN . NAME L_PAREN args R_PAREN
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    NAME            shift and go to state 45
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 46

state 23

    (14) statement -> NAME L_S_BRACKET . value R_S_BRACKET ASSIGN value
    (62) value -> NAME L_S_BRACKET . value R_S_BRACKET
    (63) value -> NAME L_S_BRACKET . value R_S_BRACKET NO VALUE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 47

state 24

    (15) statement -> NAME NO . END NI value WO ADD
    (34) statement -> NAME NO . END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (64) value -> NAME NO . ARR_LEN

    END             shift and go to state 48
    ARR_LEN         shift and go to state 49


state 25

    (30) statement -> NAME L_PAREN . args R_PAREN
    (26) args -> .
    (27) args -> . value args_m
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         reduce using rule 26 (args -> .)
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    args                           shift and go to state 50
    value                          shift and go to state 51

state 26

    (16) statement -> value WO . OUT

    OUT             shift and go to state 52


state 27

    (67) value -> value PLUS . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 53

state 28

    (68) value -> value MINUS . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 54

state 29

    (69) value -> value MULTI . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 55

state 30

    (70) value -> value DIVID . value division_tail
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 56

state 31

    (73) value -> value NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE

    DECIMAL_P       shift and go to state 57


state 32

    (23) statement -> CIRCLE NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 58


state 33

    (24) statement -> CIRCLE TYPE . COLON NAME L_PAREN params R_PAREN
    (25) statement -> CIRCLE TYPE . NO ARRAY COLON NAME L_PAREN params R_PAREN

    COLON           shift and go to state 59
    NO              shift and go to state 60


state 34

    (65) value -> L_PAREN value . R_PAREN
    (66) value -> L_PAREN value . R_PAREN NO RESULT
    (74) value -> L_PAREN value . R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         shift and go to state 61
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 35

    (60) value -> NAME .
    (62) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (63) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> NAME . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    R_PAREN         reduce using rule 60 (value -> NAME .)
    PLUS            reduce using rule 60 (value -> NAME .)
    MINUS           reduce using rule 60 (value -> NAME .)
    MULTI           reduce using rule 60 (value -> NAME .)
    DIVID           reduce using rule 60 (value -> NAME .)
    $end            reduce using rule 60 (value -> NAME .)
    R_S_BRACKET     reduce using rule 60 (value -> NAME .)
    COMMA           reduce using rule 60 (value -> NAME .)
    WO              reduce using rule 60 (value -> NAME .)
    GA              reduce using rule 60 (value -> NAME .)
    EQUAL           reduce using rule 60 (value -> NAME .)
    NOT             reduce using rule 60 (value -> NAME .)
    NOT2            reduce using rule 60 (value -> NAME .)
    LESS            reduce using rule 60 (value -> NAME .)
    LESS_EQUAL      reduce using rule 60 (value -> NAME .)
    GREATER         reduce using rule 60 (value -> NAME .)
    GREATER_EQUAL   reduce using rule 60 (value -> NAME .)
    DE              reduce using rule 60 (value -> NAME .)
    TO              reduce using rule 60 (value -> NAME .)
    KARA            reduce using rule 60 (value -> NAME .)
    MADE            reduce using rule 60 (value -> NAME .)
    KO              reduce using rule 60 (value -> NAME .)
    R_C_BRACKET     reduce using rule 60 (value -> NAME .)
    L_S_BRACKET     shift and go to state 62
    NO              shift and go to state 63

  ! NO              [ reduce using rule 60 (value -> NAME .) ]


state 36

    (37) statement -> RETURN value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    $end            reduce using rule 37 (statement -> RETURN value .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 37

    (38) statement -> IF L_PAREN . conditional R_PAREN
    (42) conditional -> . value sign value
    (52) conditional -> . value GA value DE DIVISIBLE
    (53) conditional -> . value GA value TO value DE DIVISIBLE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    conditional                    shift and go to state 64
    value                          shift and go to state 65

state 38

    (39) statement -> ELSEIF L_PAREN . conditional R_PAREN
    (42) conditional -> . value sign value
    (52) conditional -> . value GA value DE DIVISIBLE
    (53) conditional -> . value GA value TO value DE DIVISIBLE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    conditional                    shift and go to state 66
    value                          shift and go to state 65

state 39

    (54) statement -> FOR L_PAREN . NAME WO value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN

    NAME            shift and go to state 67


state 40

    (56) statement -> WHILE L_PAREN . conditional R_PAREN
    (42) conditional -> . value sign value
    (52) conditional -> . value GA value DE DIVISIBLE
    (53) conditional -> . value GA value TO value DE DIVISIBLE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    conditional                    shift and go to state 68
    value                          shift and go to state 65

state 41

    (35) value -> POW L_PAREN . args R_PAREN
    (26) args -> .
    (27) args -> . value args_m
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         reduce using rule 26 (args -> .)
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    args                           shift and go to state 69
    value                          shift and go to state 51

state 42

    (2) statement -> TYPE COLON decl_names .

    $end            reduce using rule 2 (statement -> TYPE COLON decl_names .)


state 43

    (6) statement -> TYPE COLON NAME . ASSIGN value
    (32) statement -> TYPE COLON NAME . ASSIGN NAME L_PAREN args R_PAREN
    (3) decl_names -> NAME . decl_names_m
    (4) decl_names_m -> . COMMA NAME decl_names_m
    (5) decl_names_m -> .

    ASSIGN          shift and go to state 70
    COMMA           shift and go to state 72
    $end            reduce using rule 5 (decl_names_m -> .)

    decl_names_m                   shift and go to state 71

state 44

    (8) statement -> TYPE NO ARRAY . COLON NAME ASSIGN init_array
    (33) statement -> TYPE NO ARRAY . COLON NAME ASSIGN NAME L_PAREN args R_PAREN

    COLON           shift and go to state 73


state 45

    (31) statement -> NAME ASSIGN NAME . L_PAREN args R_PAREN
    (60) value -> NAME .
    (62) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (63) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> NAME . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 74
    PLUS            reduce using rule 60 (value -> NAME .)
    MINUS           reduce using rule 60 (value -> NAME .)
    MULTI           reduce using rule 60 (value -> NAME .)
    DIVID           reduce using rule 60 (value -> NAME .)
    $end            reduce using rule 60 (value -> NAME .)
    L_S_BRACKET     shift and go to state 62
    NO              shift and go to state 63

  ! NO              [ reduce using rule 60 (value -> NAME .) ]


state 46

    (7) statement -> NAME ASSIGN value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    $end            reduce using rule 7 (statement -> NAME ASSIGN value .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 47

    (14) statement -> NAME L_S_BRACKET value . R_S_BRACKET ASSIGN value
    (62) value -> NAME L_S_BRACKET value . R_S_BRACKET
    (63) value -> NAME L_S_BRACKET value . R_S_BRACKET NO VALUE
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_S_BRACKET     shift and go to state 75
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 48

    (15) statement -> NAME NO END . NI value WO ADD
    (34) statement -> NAME NO END . NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD

    NI              shift and go to state 76


state 49

    (64) value -> NAME NO ARR_LEN .

    WO              reduce using rule 64 (value -> NAME NO ARR_LEN .)
    PLUS            reduce using rule 64 (value -> NAME NO ARR_LEN .)
    MINUS           reduce using rule 64 (value -> NAME NO ARR_LEN .)
    MULTI           reduce using rule 64 (value -> NAME NO ARR_LEN .)
    DIVID           reduce using rule 64 (value -> NAME NO ARR_LEN .)
    NO              reduce using rule 64 (value -> NAME NO ARR_LEN .)
    R_PAREN         reduce using rule 64 (value -> NAME NO ARR_LEN .)
    $end            reduce using rule 64 (value -> NAME NO ARR_LEN .)
    R_S_BRACKET     reduce using rule 64 (value -> NAME NO ARR_LEN .)
    COMMA           reduce using rule 64 (value -> NAME NO ARR_LEN .)
    GA              reduce using rule 64 (value -> NAME NO ARR_LEN .)
    EQUAL           reduce using rule 64 (value -> NAME NO ARR_LEN .)
    NOT             reduce using rule 64 (value -> NAME NO ARR_LEN .)
    NOT2            reduce using rule 64 (value -> NAME NO ARR_LEN .)
    LESS            reduce using rule 64 (value -> NAME NO ARR_LEN .)
    LESS_EQUAL      reduce using rule 64 (value -> NAME NO ARR_LEN .)
    GREATER         reduce using rule 64 (value -> NAME NO ARR_LEN .)
    GREATER_EQUAL   reduce using rule 64 (value -> NAME NO ARR_LEN .)
    DE              reduce using rule 64 (value -> NAME NO ARR_LEN .)
    TO              reduce using rule 64 (value -> NAME NO ARR_LEN .)
    KARA            reduce using rule 64 (value -> NAME NO ARR_LEN .)
    MADE            reduce using rule 64 (value -> NAME NO ARR_LEN .)
    KO              reduce using rule 64 (value -> NAME NO ARR_LEN .)
    R_C_BRACKET     reduce using rule 64 (value -> NAME NO ARR_LEN .)


state 50

    (30) statement -> NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 77


state 51

    (27) args -> value . args_m
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (28) args_m -> . COMMA value args_m
    (29) args_m -> .

    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31
    COMMA           shift and go to state 79
    R_PAREN         reduce using rule 29 (args_m -> .)

    args_m                         shift and go to state 78

state 52

    (16) statement -> value WO OUT .

    $end            reduce using rule 16 (statement -> value WO OUT .)


state 53

    (67) value -> value PLUS value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    WO              reduce using rule 67 (value -> value PLUS value .)
    PLUS            reduce using rule 67 (value -> value PLUS value .)
    MINUS           reduce using rule 67 (value -> value PLUS value .)
    NO              reduce using rule 67 (value -> value PLUS value .)
    R_PAREN         reduce using rule 67 (value -> value PLUS value .)
    $end            reduce using rule 67 (value -> value PLUS value .)
    R_S_BRACKET     reduce using rule 67 (value -> value PLUS value .)
    COMMA           reduce using rule 67 (value -> value PLUS value .)
    GA              reduce using rule 67 (value -> value PLUS value .)
    EQUAL           reduce using rule 67 (value -> value PLUS value .)
    NOT             reduce using rule 67 (value -> value PLUS value .)
    NOT2            reduce using rule 67 (value -> value PLUS value .)
    LESS            reduce using rule 67 (value -> value PLUS value .)
    LESS_EQUAL      reduce using rule 67 (value -> value PLUS value .)
    GREATER         reduce using rule 67 (value -> value PLUS value .)
    GREATER_EQUAL   reduce using rule 67 (value -> value PLUS value .)
    DE              reduce using rule 67 (value -> value PLUS value .)
    TO              reduce using rule 67 (value -> value PLUS value .)
    KARA            reduce using rule 67 (value -> value PLUS value .)
    MADE            reduce using rule 67 (value -> value PLUS value .)
    KO              reduce using rule 67 (value -> value PLUS value .)
    R_C_BRACKET     reduce using rule 67 (value -> value PLUS value .)
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30

  ! MULTI           [ reduce using rule 67 (value -> value PLUS value .) ]
  ! DIVID           [ reduce using rule 67 (value -> value PLUS value .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! NO              [ shift and go to state 31 ]


state 54

    (68) value -> value MINUS value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    WO              reduce using rule 68 (value -> value MINUS value .)
    PLUS            reduce using rule 68 (value -> value MINUS value .)
    MINUS           reduce using rule 68 (value -> value MINUS value .)
    NO              reduce using rule 68 (value -> value MINUS value .)
    R_PAREN         reduce using rule 68 (value -> value MINUS value .)
    $end            reduce using rule 68 (value -> value MINUS value .)
    R_S_BRACKET     reduce using rule 68 (value -> value MINUS value .)
    COMMA           reduce using rule 68 (value -> value MINUS value .)
    GA              reduce using rule 68 (value -> value MINUS value .)
    EQUAL           reduce using rule 68 (value -> value MINUS value .)
    NOT             reduce using rule 68 (value -> value MINUS value .)
    NOT2            reduce using rule 68 (value -> value MINUS value .)
    LESS            reduce using rule 68 (value -> value MINUS value .)
    LESS_EQUAL      reduce using rule 68 (value -> value MINUS value .)
    GREATER         reduce using rule 68 (value -> value MINUS value .)
    GREATER_EQUAL   reduce using rule 68 (value -> value MINUS value .)
    DE              reduce using rule 68 (value -> value MINUS value .)
    TO              reduce using rule 68 (value -> value MINUS value .)
    KARA            reduce using rule 68 (value -> value MINUS value .)
    MADE            reduce using rule 68 (value -> value MINUS value .)
    KO              reduce using rule 68 (value -> value MINUS value .)
    R_C_BRACKET     reduce using rule 68 (value -> value MINUS value .)
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30

  ! MULTI           [ reduce using rule 68 (value -> value MINUS value .) ]
  ! DIVID           [ reduce using rule 68 (value -> value MINUS value .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! NO              [ shift and go to state 31 ]


state 55

    (69) value -> value MULTI value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    WO              reduce using rule 69 (value -> value MULTI value .)
    PLUS            reduce using rule 69 (value -> value MULTI value .)
    MINUS           reduce using rule 69 (value -> value MULTI value .)
    MULTI           reduce using rule 69 (value -> value MULTI value .)
    DIVID           reduce using rule 69 (value -> value MULTI value .)
    NO              reduce using rule 69 (value -> value MULTI value .)
    R_PAREN         reduce using rule 69 (value -> value MULTI value .)
    $end            reduce using rule 69 (value -> value MULTI value .)
    R_S_BRACKET     reduce using rule 69 (value -> value MULTI value .)
    COMMA           reduce using rule 69 (value -> value MULTI value .)
    GA              reduce using rule 69 (value -> value MULTI value .)
    EQUAL           reduce using rule 69 (value -> value MULTI value .)
    NOT             reduce using rule 69 (value -> value MULTI value .)
    NOT2            reduce using rule 69 (value -> value MULTI value .)
    LESS            reduce using rule 69 (value -> value MULTI value .)
    LESS_EQUAL      reduce using rule 69 (value -> value MULTI value .)
    GREATER         reduce using rule 69 (value -> value MULTI value .)
    GREATER_EQUAL   reduce using rule 69 (value -> value MULTI value .)
    DE              reduce using rule 69 (value -> value MULTI value .)
    TO              reduce using rule 69 (value -> value MULTI value .)
    KARA            reduce using rule 69 (value -> value MULTI value .)
    MADE            reduce using rule 69 (value -> value MULTI value .)
    KO              reduce using rule 69 (value -> value MULTI value .)
    R_C_BRACKET     reduce using rule 69 (value -> value MULTI value .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! MULTI           [ shift and go to state 29 ]
  ! DIVID           [ shift and go to state 30 ]
  ! NO              [ shift and go to state 31 ]


state 56

    (70) value -> value DIVID value . division_tail
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (71) division_tail -> . NO SHOW
    (72) division_tail -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTI resolved as shift
  ! shift/reduce conflict for DIVID resolved as shift
  ! shift/reduce conflict for NO resolved as shift
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 81
    WO              reduce using rule 72 (division_tail -> .)
    R_PAREN         reduce using rule 72 (division_tail -> .)
    $end            reduce using rule 72 (division_tail -> .)
    R_S_BRACKET     reduce using rule 72 (division_tail -> .)
    COMMA           reduce using rule 72 (division_tail -> .)
    GA              reduce using rule 72 (division_tail -> .)
    EQUAL           reduce using rule 72 (division_tail -> .)
    NOT             reduce using rule 72 (division_tail -> .)
    NOT2            reduce using rule 72 (division_tail -> .)
    LESS            reduce using rule 72 (division_tail -> .)
    LESS_EQUAL      reduce using rule 72 (division_tail -> .)
    GREATER         reduce using rule 72 (division_tail -> .)
    GREATER_EQUAL   reduce using rule 72 (division_tail -> .)
    DE              reduce using rule 72 (division_tail -> .)
    TO              reduce using rule 72 (division_tail -> .)
    KARA            reduce using rule 72 (division_tail -> .)
    MADE            reduce using rule 72 (division_tail -> .)
    KO              reduce using rule 72 (division_tail -> .)
    R_C_BRACKET     reduce using rule 72 (division_tail -> .)

  ! PLUS            [ reduce using rule 72 (division_tail -> .) ]
  ! MINUS           [ reduce using rule 72 (division_tail -> .) ]
  ! MULTI           [ reduce using rule 72 (division_tail -> .) ]
  ! DIVID           [ reduce using rule 72 (division_tail -> .) ]
  ! NO              [ reduce using rule 72 (division_tail -> .) ]

    division_tail                  shift and go to state 80

state 57

    (73) value -> value NO DECIMAL_P . BELOW WO ROUNDED_UP VALUE

    BELOW           shift and go to state 82


state 58

    (23) statement -> CIRCLE NAME L_PAREN . params R_PAREN
    (17) params -> .
    (18) params -> . TYPE COLON NAME params_m
    (19) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 17 (params -> .)
    TYPE            shift and go to state 84

    params                         shift and go to state 83

state 59

    (24) statement -> CIRCLE TYPE COLON . NAME L_PAREN params R_PAREN

    NAME            shift and go to state 85


state 60

    (25) statement -> CIRCLE TYPE NO . ARRAY COLON NAME L_PAREN params R_PAREN

    ARRAY           shift and go to state 86


state 61

    (65) value -> L_PAREN value R_PAREN .
    (66) value -> L_PAREN value R_PAREN . NO RESULT
    (74) value -> L_PAREN value R_PAREN . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

  ! shift/reduce conflict for NO resolved as shift
    WO              reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    PLUS            reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    MINUS           reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    MULTI           reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    DIVID           reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    R_PAREN         reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    $end            reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    R_S_BRACKET     reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    COMMA           reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    GA              reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    EQUAL           reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    NOT             reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    NOT2            reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    LESS            reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    LESS_EQUAL      reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    GREATER         reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    GREATER_EQUAL   reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    DE              reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    TO              reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    KARA            reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    MADE            reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    KO              reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    R_C_BRACKET     reduce using rule 65 (value -> L_PAREN value R_PAREN .)
    NO              shift and go to state 87

  ! NO              [ reduce using rule 65 (value -> L_PAREN value R_PAREN .) ]


state 62

    (62) value -> NAME L_S_BRACKET . value R_S_BRACKET
    (63) value -> NAME L_S_BRACKET . value R_S_BRACKET NO VALUE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 88

state 63

    (64) value -> NAME NO . ARR_LEN

    ARR_LEN         shift and go to state 49


state 64

    (38) statement -> IF L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 89


state 65

    (42) conditional -> value . sign value
    (52) conditional -> value . GA value DE DIVISIBLE
    (53) conditional -> value . GA value TO value DE DIVISIBLE
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (43) sign -> . EQUAL
    (44) sign -> . NOT EQUAL
    (45) sign -> . NOT2
    (46) sign -> . LESS
    (47) sign -> . LESS EQUAL
    (48) sign -> . LESS_EQUAL
    (49) sign -> . GREATER
    (50) sign -> . GREATER EQUAL
    (51) sign -> . GREATER_EQUAL

    GA              shift and go to state 91
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31
    EQUAL           shift and go to state 92
    NOT             shift and go to state 93
    NOT2            shift and go to state 94
    LESS            shift and go to state 95
    LESS_EQUAL      shift and go to state 96
    GREATER         shift and go to state 97
    GREATER_EQUAL   shift and go to state 98

    sign                           shift and go to state 90

state 66

    (39) statement -> ELSEIF L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 99


state 67

    (54) statement -> FOR L_PAREN NAME . WO value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN

    WO              shift and go to state 100


state 68

    (56) statement -> WHILE L_PAREN conditional . R_PAREN

    R_PAREN         shift and go to state 101


state 69

    (35) value -> POW L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 102


state 70

    (6) statement -> TYPE COLON NAME ASSIGN . value
    (32) statement -> TYPE COLON NAME ASSIGN . NAME L_PAREN args R_PAREN
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    NAME            shift and go to state 103
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 104

state 71

    (3) decl_names -> NAME decl_names_m .

    $end            reduce using rule 3 (decl_names -> NAME decl_names_m .)


state 72

    (4) decl_names_m -> COMMA . NAME decl_names_m

    NAME            shift and go to state 105


state 73

    (8) statement -> TYPE NO ARRAY COLON . NAME ASSIGN init_array
    (33) statement -> TYPE NO ARRAY COLON . NAME ASSIGN NAME L_PAREN args R_PAREN

    NAME            shift and go to state 106


state 74

    (31) statement -> NAME ASSIGN NAME L_PAREN . args R_PAREN
    (26) args -> .
    (27) args -> . value args_m
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         reduce using rule 26 (args -> .)
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    args                           shift and go to state 107
    value                          shift and go to state 51

state 75

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET . ASSIGN value
    (62) value -> NAME L_S_BRACKET value R_S_BRACKET .
    (63) value -> NAME L_S_BRACKET value R_S_BRACKET . NO VALUE

  ! shift/reduce conflict for NO resolved as shift
    ASSIGN          shift and go to state 108
    WO              reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NO              shift and go to state 109

  ! NO              [ reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .) ]


state 76

    (15) statement -> NAME NO END NI . value WO ADD
    (34) statement -> NAME NO END NI . NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    NAME            shift and go to state 110
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 111

state 77

    (30) statement -> NAME L_PAREN args R_PAREN .

    $end            reduce using rule 30 (statement -> NAME L_PAREN args R_PAREN .)


state 78

    (27) args -> value args_m .

    R_PAREN         reduce using rule 27 (args -> value args_m .)


state 79

    (28) args_m -> COMMA . value args_m
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 112

state 80

    (70) value -> value DIVID value division_tail .

    WO              reduce using rule 70 (value -> value DIVID value division_tail .)
    PLUS            reduce using rule 70 (value -> value DIVID value division_tail .)
    MINUS           reduce using rule 70 (value -> value DIVID value division_tail .)
    MULTI           reduce using rule 70 (value -> value DIVID value division_tail .)
    DIVID           reduce using rule 70 (value -> value DIVID value division_tail .)
    NO              reduce using rule 70 (value -> value DIVID value division_tail .)
    R_PAREN         reduce using rule 70 (value -> value DIVID value division_tail .)
    $end            reduce using rule 70 (value -> value DIVID value division_tail .)
    R_S_BRACKET     reduce using rule 70 (value -> value DIVID value division_tail .)
    COMMA           reduce using rule 70 (value -> value DIVID value division_tail .)
    GA              reduce using rule 70 (value -> value DIVID value division_tail .)
    EQUAL           reduce using rule 70 (value -> value DIVID value division_tail .)
    NOT             reduce using rule 70 (value -> value DIVID value division_tail .)
    NOT2            reduce using rule 70 (value -> value DIVID value division_tail .)
    LESS            reduce using rule 70 (value -> value DIVID value division_tail .)
    LESS_EQUAL      reduce using rule 70 (value -> value DIVID value division_tail .)
    GREATER         reduce using rule 70 (value -> value DIVID value division_tail .)
    GREATER_EQUAL   reduce using rule 70 (value -> value DIVID value division_tail .)
    DE              reduce using rule 70 (value -> value DIVID value division_tail .)
    TO              reduce using rule 70 (value -> value DIVID value division_tail .)
    KARA            reduce using rule 70 (value -> value DIVID value division_tail .)
    MADE            reduce using rule 70 (value -> value DIVID value division_tail .)
    KO              reduce using rule 70 (value -> value DIVID value division_tail .)
    R_C_BRACKET     reduce using rule 70 (value -> value DIVID value division_tail .)


state 81

    (73) value -> value NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (71) division_tail -> NO . SHOW

    DECIMAL_P       shift and go to state 57
    SHOW            shift and go to state 113


state 82

    (73) value -> value NO DECIMAL_P BELOW . WO ROUNDED_UP VALUE

    WO              shift and go to state 114


state 83

    (23) statement -> CIRCLE NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 115


state 84

    (18) params -> TYPE . COLON NAME params_m
    (19) params -> TYPE . NO ARRAY COLON NAME params_m

    COLON           shift and go to state 116
    NO              shift and go to state 117


state 85

    (24) statement -> CIRCLE TYPE COLON NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 118


state 86

    (25) statement -> CIRCLE TYPE NO ARRAY . COLON NAME L_PAREN params R_PAREN

    COLON           shift and go to state 119


state 87

    (66) value -> L_PAREN value R_PAREN NO . RESULT
    (74) value -> L_PAREN value R_PAREN NO . DECIMAL_P BELOW WO ROUNDED_UP VALUE

    RESULT          shift and go to state 120
    DECIMAL_P       shift and go to state 121


state 88

    (62) value -> NAME L_S_BRACKET value . R_S_BRACKET
    (63) value -> NAME L_S_BRACKET value . R_S_BRACKET NO VALUE
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_S_BRACKET     shift and go to state 122
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 89

    (38) statement -> IF L_PAREN conditional R_PAREN .

    $end            reduce using rule 38 (statement -> IF L_PAREN conditional R_PAREN .)


state 90

    (42) conditional -> value sign . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 123

state 91

    (52) conditional -> value GA . value DE DIVISIBLE
    (53) conditional -> value GA . value TO value DE DIVISIBLE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 124

state 92

    (43) sign -> EQUAL .

    POW             reduce using rule 43 (sign -> EQUAL .)
    NUMBER          reduce using rule 43 (sign -> EQUAL .)
    FLOAT           reduce using rule 43 (sign -> EQUAL .)
    NAME            reduce using rule 43 (sign -> EQUAL .)
    STRING          reduce using rule 43 (sign -> EQUAL .)
    L_PAREN         reduce using rule 43 (sign -> EQUAL .)


state 93

    (44) sign -> NOT . EQUAL

    EQUAL           shift and go to state 125


state 94

    (45) sign -> NOT2 .

    POW             reduce using rule 45 (sign -> NOT2 .)
    NUMBER          reduce using rule 45 (sign -> NOT2 .)
    FLOAT           reduce using rule 45 (sign -> NOT2 .)
    NAME            reduce using rule 45 (sign -> NOT2 .)
    STRING          reduce using rule 45 (sign -> NOT2 .)
    L_PAREN         reduce using rule 45 (sign -> NOT2 .)


state 95

    (46) sign -> LESS .
    (47) sign -> LESS . EQUAL

    POW             reduce using rule 46 (sign -> LESS .)
    NUMBER          reduce using rule 46 (sign -> LESS .)
    FLOAT           reduce using rule 46 (sign -> LESS .)
    NAME            reduce using rule 46 (sign -> LESS .)
    STRING          reduce using rule 46 (sign -> LESS .)
    L_PAREN         reduce using rule 46 (sign -> LESS .)
    EQUAL           shift and go to state 126


state 96

    (48) sign -> LESS_EQUAL .

    POW             reduce using rule 48 (sign -> LESS_EQUAL .)
    NUMBER          reduce using rule 48 (sign -> LESS_EQUAL .)
    FLOAT           reduce using rule 48 (sign -> LESS_EQUAL .)
    NAME            reduce using rule 48 (sign -> LESS_EQUAL .)
    STRING          reduce using rule 48 (sign -> LESS_EQUAL .)
    L_PAREN         reduce using rule 48 (sign -> LESS_EQUAL .)


state 97

    (49) sign -> GREATER .
    (50) sign -> GREATER . EQUAL

    POW             reduce using rule 49 (sign -> GREATER .)
    NUMBER          reduce using rule 49 (sign -> GREATER .)
    FLOAT           reduce using rule 49 (sign -> GREATER .)
    NAME            reduce using rule 49 (sign -> GREATER .)
    STRING          reduce using rule 49 (sign -> GREATER .)
    L_PAREN         reduce using rule 49 (sign -> GREATER .)
    EQUAL           shift and go to state 127


state 98

    (51) sign -> GREATER_EQUAL .

    POW             reduce using rule 51 (sign -> GREATER_EQUAL .)
    NUMBER          reduce using rule 51 (sign -> GREATER_EQUAL .)
    FLOAT           reduce using rule 51 (sign -> GREATER_EQUAL .)
    NAME            reduce using rule 51 (sign -> GREATER_EQUAL .)
    STRING          reduce using rule 51 (sign -> GREATER_EQUAL .)
    L_PAREN         reduce using rule 51 (sign -> GREATER_EQUAL .)


state 99

    (39) statement -> ELSEIF L_PAREN conditional R_PAREN .

    $end            reduce using rule 39 (statement -> ELSEIF L_PAREN conditional R_PAREN .)


state 100

    (54) statement -> FOR L_PAREN NAME WO . value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 128

state 101

    (56) statement -> WHILE L_PAREN conditional R_PAREN .

    $end            reduce using rule 56 (statement -> WHILE L_PAREN conditional R_PAREN .)


state 102

    (35) value -> POW L_PAREN args R_PAREN .

    WO              reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    PLUS            reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    MINUS           reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    MULTI           reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    DIVID           reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    NO              reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    R_PAREN         reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    $end            reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    R_S_BRACKET     reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    COMMA           reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    GA              reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    EQUAL           reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    NOT             reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    NOT2            reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    LESS            reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    LESS_EQUAL      reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    GREATER         reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    GREATER_EQUAL   reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    DE              reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    TO              reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    KARA            reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    MADE            reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    KO              reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)
    R_C_BRACKET     reduce using rule 35 (value -> POW L_PAREN args R_PAREN .)


state 103

    (32) statement -> TYPE COLON NAME ASSIGN NAME . L_PAREN args R_PAREN
    (60) value -> NAME .
    (62) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (63) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> NAME . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 129
    PLUS            reduce using rule 60 (value -> NAME .)
    MINUS           reduce using rule 60 (value -> NAME .)
    MULTI           reduce using rule 60 (value -> NAME .)
    DIVID           reduce using rule 60 (value -> NAME .)
    $end            reduce using rule 60 (value -> NAME .)
    L_S_BRACKET     shift and go to state 62
    NO              shift and go to state 63

  ! NO              [ reduce using rule 60 (value -> NAME .) ]


state 104

    (6) statement -> TYPE COLON NAME ASSIGN value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    $end            reduce using rule 6 (statement -> TYPE COLON NAME ASSIGN value .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 105

    (4) decl_names_m -> COMMA NAME . decl_names_m
    (4) decl_names_m -> . COMMA NAME decl_names_m
    (5) decl_names_m -> .

    COMMA           shift and go to state 72
    $end            reduce using rule 5 (decl_names_m -> .)

    decl_names_m                   shift and go to state 130

state 106

    (8) statement -> TYPE NO ARRAY COLON NAME . ASSIGN init_array
    (33) statement -> TYPE NO ARRAY COLON NAME . ASSIGN NAME L_PAREN args R_PAREN

    ASSIGN          shift and go to state 131


state 107

    (31) statement -> NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 132


state 108

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 133

state 109

    (63) value -> NAME L_S_BRACKET value R_S_BRACKET NO . VALUE

    VALUE           shift and go to state 134


state 110

    (34) statement -> NAME NO END NI NAME . L_PAREN args R_PAREN NO RETURN_VAL WO ADD
    (60) value -> NAME .
    (62) value -> NAME . L_S_BRACKET value R_S_BRACKET
    (63) value -> NAME . L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> NAME . NO ARR_LEN

  ! shift/reduce conflict for NO resolved as shift
    L_PAREN         shift and go to state 135
    WO              reduce using rule 60 (value -> NAME .)
    PLUS            reduce using rule 60 (value -> NAME .)
    MINUS           reduce using rule 60 (value -> NAME .)
    MULTI           reduce using rule 60 (value -> NAME .)
    DIVID           reduce using rule 60 (value -> NAME .)
    L_S_BRACKET     shift and go to state 62
    NO              shift and go to state 63

  ! NO              [ reduce using rule 60 (value -> NAME .) ]


state 111

    (15) statement -> NAME NO END NI value . WO ADD
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    WO              shift and go to state 136
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 112

    (28) args_m -> COMMA value . args_m
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (28) args_m -> . COMMA value args_m
    (29) args_m -> .

    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31
    COMMA           shift and go to state 79
    R_PAREN         reduce using rule 29 (args_m -> .)

    args_m                         shift and go to state 137

state 113

    (71) division_tail -> NO SHOW .

    WO              reduce using rule 71 (division_tail -> NO SHOW .)
    PLUS            reduce using rule 71 (division_tail -> NO SHOW .)
    MINUS           reduce using rule 71 (division_tail -> NO SHOW .)
    MULTI           reduce using rule 71 (division_tail -> NO SHOW .)
    DIVID           reduce using rule 71 (division_tail -> NO SHOW .)
    NO              reduce using rule 71 (division_tail -> NO SHOW .)
    R_PAREN         reduce using rule 71 (division_tail -> NO SHOW .)
    $end            reduce using rule 71 (division_tail -> NO SHOW .)
    R_S_BRACKET     reduce using rule 71 (division_tail -> NO SHOW .)
    COMMA           reduce using rule 71 (division_tail -> NO SHOW .)
    GA              reduce using rule 71 (division_tail -> NO SHOW .)
    EQUAL           reduce using rule 71 (division_tail -> NO SHOW .)
    NOT             reduce using rule 71 (division_tail -> NO SHOW .)
    NOT2            reduce using rule 71 (division_tail -> NO SHOW .)
    LESS            reduce using rule 71 (division_tail -> NO SHOW .)
    LESS_EQUAL      reduce using rule 71 (division_tail -> NO SHOW .)
    GREATER         reduce using rule 71 (division_tail -> NO SHOW .)
    GREATER_EQUAL   reduce using rule 71 (division_tail -> NO SHOW .)
    DE              reduce using rule 71 (division_tail -> NO SHOW .)
    TO              reduce using rule 71 (division_tail -> NO SHOW .)
    KARA            reduce using rule 71 (division_tail -> NO SHOW .)
    MADE            reduce using rule 71 (division_tail -> NO SHOW .)
    KO              reduce using rule 71 (division_tail -> NO SHOW .)
    R_C_BRACKET     reduce using rule 71 (division_tail -> NO SHOW .)


state 114

    (73) value -> value NO DECIMAL_P BELOW WO . ROUNDED_UP VALUE

    ROUNDED_UP      shift and go to state 138


state 115

    (23) statement -> CIRCLE NAME L_PAREN params R_PAREN .

    $end            reduce using rule 23 (statement -> CIRCLE NAME L_PAREN params R_PAREN .)


state 116

    (18) params -> TYPE COLON . NAME params_m

    NAME            shift and go to state 139


state 117

    (19) params -> TYPE NO . ARRAY COLON NAME params_m

    ARRAY           shift and go to state 140


state 118

    (24) statement -> CIRCLE TYPE COLON NAME L_PAREN . params R_PAREN
    (17) params -> .
    (18) params -> . TYPE COLON NAME params_m
    (19) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 17 (params -> .)
    TYPE            shift and go to state 84

    params                         shift and go to state 141

state 119

    (25) statement -> CIRCLE TYPE NO ARRAY COLON . NAME L_PAREN params R_PAREN

    NAME            shift and go to state 142


state 120

    (66) value -> L_PAREN value R_PAREN NO RESULT .

    WO              reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    PLUS            reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    MINUS           reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    MULTI           reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    DIVID           reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    NO              reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_PAREN         reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    $end            reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_S_BRACKET     reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    COMMA           reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    GA              reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    EQUAL           reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    NOT             reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    NOT2            reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    LESS            reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    LESS_EQUAL      reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    GREATER         reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    GREATER_EQUAL   reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    DE              reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    TO              reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    KARA            reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    MADE            reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    KO              reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)
    R_C_BRACKET     reduce using rule 66 (value -> L_PAREN value R_PAREN NO RESULT .)


state 121

    (74) value -> L_PAREN value R_PAREN NO DECIMAL_P . BELOW WO ROUNDED_UP VALUE

    BELOW           shift and go to state 143


state 122

    (62) value -> NAME L_S_BRACKET value R_S_BRACKET .
    (63) value -> NAME L_S_BRACKET value R_S_BRACKET . NO VALUE

  ! shift/reduce conflict for NO resolved as shift
    R_PAREN         reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    PLUS            reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MINUS           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MULTI           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DIVID           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    $end            reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    R_S_BRACKET     reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    COMMA           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    WO              reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GA              reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    EQUAL           reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NOT             reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NOT2            reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LESS            reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    LESS_EQUAL      reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GREATER         reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    GREATER_EQUAL   reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    DE              reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    TO              reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    KARA            reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    MADE            reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    KO              reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    R_C_BRACKET     reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .)
    NO              shift and go to state 109

  ! NO              [ reduce using rule 62 (value -> NAME L_S_BRACKET value R_S_BRACKET .) ]


state 123

    (42) conditional -> value sign value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         reduce using rule 42 (conditional -> value sign value .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 124

    (52) conditional -> value GA value . DE DIVISIBLE
    (53) conditional -> value GA value . TO value DE DIVISIBLE
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    DE              shift and go to state 144
    TO              shift and go to state 145
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 125

    (44) sign -> NOT EQUAL .

    POW             reduce using rule 44 (sign -> NOT EQUAL .)
    NUMBER          reduce using rule 44 (sign -> NOT EQUAL .)
    FLOAT           reduce using rule 44 (sign -> NOT EQUAL .)
    NAME            reduce using rule 44 (sign -> NOT EQUAL .)
    STRING          reduce using rule 44 (sign -> NOT EQUAL .)
    L_PAREN         reduce using rule 44 (sign -> NOT EQUAL .)


state 126

    (47) sign -> LESS EQUAL .

    POW             reduce using rule 47 (sign -> LESS EQUAL .)
    NUMBER          reduce using rule 47 (sign -> LESS EQUAL .)
    FLOAT           reduce using rule 47 (sign -> LESS EQUAL .)
    NAME            reduce using rule 47 (sign -> LESS EQUAL .)
    STRING          reduce using rule 47 (sign -> LESS EQUAL .)
    L_PAREN         reduce using rule 47 (sign -> LESS EQUAL .)


state 127

    (50) sign -> GREATER EQUAL .

    POW             reduce using rule 50 (sign -> GREATER EQUAL .)
    NUMBER          reduce using rule 50 (sign -> GREATER EQUAL .)
    FLOAT           reduce using rule 50 (sign -> GREATER EQUAL .)
    NAME            reduce using rule 50 (sign -> GREATER EQUAL .)
    STRING          reduce using rule 50 (sign -> GREATER EQUAL .)
    L_PAREN         reduce using rule 50 (sign -> GREATER EQUAL .)


state 128

    (54) statement -> FOR L_PAREN NAME WO value . KARA value MADE NUMBER ZUTSU INCREASE R_PAREN
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    KARA            shift and go to state 146
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 129

    (32) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN . args R_PAREN
    (26) args -> .
    (27) args -> . value args_m
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         reduce using rule 26 (args -> .)
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    args                           shift and go to state 147
    value                          shift and go to state 51

state 130

    (4) decl_names_m -> COMMA NAME decl_names_m .

    $end            reduce using rule 4 (decl_names_m -> COMMA NAME decl_names_m .)


state 131

    (8) statement -> TYPE NO ARRAY COLON NAME ASSIGN . init_array
    (33) statement -> TYPE NO ARRAY COLON NAME ASSIGN . NAME L_PAREN args R_PAREN
    (9) init_array -> . L_C_BRACKET R_C_BRACKET
    (10) init_array -> . L_C_BRACKET init_array_val R_C_BRACKET
    (13) init_array -> . L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET

    NAME            shift and go to state 148
    L_C_BRACKET     shift and go to state 150

    init_array                     shift and go to state 149

state 132

    (31) statement -> NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 31 (statement -> NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 133

    (14) statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    $end            reduce using rule 14 (statement -> NAME L_S_BRACKET value R_S_BRACKET ASSIGN value .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 134

    (63) value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .

    WO              reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    PLUS            reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MINUS           reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MULTI           reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DIVID           reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NO              reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_PAREN         reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    $end            reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_S_BRACKET     reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    COMMA           reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GA              reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    EQUAL           reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NOT             reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    NOT2            reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LESS            reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    LESS_EQUAL      reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GREATER         reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    GREATER_EQUAL   reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    DE              reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    TO              reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    KARA            reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    MADE            reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    KO              reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)
    R_C_BRACKET     reduce using rule 63 (value -> NAME L_S_BRACKET value R_S_BRACKET NO VALUE .)


state 135

    (34) statement -> NAME NO END NI NAME L_PAREN . args R_PAREN NO RETURN_VAL WO ADD
    (26) args -> .
    (27) args -> . value args_m
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         reduce using rule 26 (args -> .)
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    args                           shift and go to state 151
    value                          shift and go to state 51

state 136

    (15) statement -> NAME NO END NI value WO . ADD

    ADD             shift and go to state 152


state 137

    (28) args_m -> COMMA value args_m .

    R_PAREN         reduce using rule 28 (args_m -> COMMA value args_m .)


state 138

    (73) value -> value NO DECIMAL_P BELOW WO ROUNDED_UP . VALUE

    VALUE           shift and go to state 153


state 139

    (18) params -> TYPE COLON NAME . params_m
    (20) params_m -> . COMMA TYPE COLON NAME params_m
    (21) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (22) params_m -> .

    COMMA           shift and go to state 155
    R_PAREN         reduce using rule 22 (params_m -> .)

    params_m                       shift and go to state 154

state 140

    (19) params -> TYPE NO ARRAY . COLON NAME params_m

    COLON           shift and go to state 156


state 141

    (24) statement -> CIRCLE TYPE COLON NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 157


state 142

    (25) statement -> CIRCLE TYPE NO ARRAY COLON NAME . L_PAREN params R_PAREN

    L_PAREN         shift and go to state 158


state 143

    (74) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW . WO ROUNDED_UP VALUE

    WO              shift and go to state 159


state 144

    (52) conditional -> value GA value DE . DIVISIBLE

    DIVISIBLE       shift and go to state 160


state 145

    (53) conditional -> value GA value TO . value DE DIVISIBLE
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 161

state 146

    (54) statement -> FOR L_PAREN NAME WO value KARA . value MADE NUMBER ZUTSU INCREASE R_PAREN
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 162

state 147

    (32) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 163


state 148

    (33) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME . L_PAREN args R_PAREN

    L_PAREN         shift and go to state 164


state 149

    (8) statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array .

    $end            reduce using rule 8 (statement -> TYPE NO ARRAY COLON NAME ASSIGN init_array .)


state 150

    (9) init_array -> L_C_BRACKET . R_C_BRACKET
    (10) init_array -> L_C_BRACKET . init_array_val R_C_BRACKET
    (13) init_array -> L_C_BRACKET . value KO NO UNDEF NO VALUE R_C_BRACKET
    (11) init_array_val -> . init_array_val COMMA value
    (12) init_array_val -> . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_C_BRACKET     shift and go to state 165
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    init_array_val                 shift and go to state 166
    value                          shift and go to state 167

state 151

    (34) statement -> NAME NO END NI NAME L_PAREN args . R_PAREN NO RETURN_VAL WO ADD

    R_PAREN         shift and go to state 168


state 152

    (15) statement -> NAME NO END NI value WO ADD .

    $end            reduce using rule 15 (statement -> NAME NO END NI value WO ADD .)


state 153

    (73) value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .

    WO              reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    PLUS            reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MINUS           reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MULTI           reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVID           reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NO              reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_PAREN         reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    $end            reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_S_BRACKET     reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    COMMA           reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GA              reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    EQUAL           reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT             reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT2            reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS            reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS_EQUAL      reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER         reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER_EQUAL   reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DE              reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    TO              reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KARA            reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MADE            reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KO              reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_C_BRACKET     reduce using rule 73 (value -> value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)


state 154

    (18) params -> TYPE COLON NAME params_m .

    R_PAREN         reduce using rule 18 (params -> TYPE COLON NAME params_m .)


state 155

    (20) params_m -> COMMA . TYPE COLON NAME params_m
    (21) params_m -> COMMA . TYPE NO ARRAY COLON NAME params_m

    TYPE            shift and go to state 169


state 156

    (19) params -> TYPE NO ARRAY COLON . NAME params_m

    NAME            shift and go to state 170


state 157

    (24) statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN .

    $end            reduce using rule 24 (statement -> CIRCLE TYPE COLON NAME L_PAREN params R_PAREN .)


state 158

    (25) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN . params R_PAREN
    (17) params -> .
    (18) params -> . TYPE COLON NAME params_m
    (19) params -> . TYPE NO ARRAY COLON NAME params_m

    R_PAREN         reduce using rule 17 (params -> .)
    TYPE            shift and go to state 84

    params                         shift and go to state 171

state 159

    (74) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO . ROUNDED_UP VALUE

    ROUNDED_UP      shift and go to state 172


state 160

    (52) conditional -> value GA value DE DIVISIBLE .

    R_PAREN         reduce using rule 52 (conditional -> value GA value DE DIVISIBLE .)


state 161

    (53) conditional -> value GA value TO value . DE DIVISIBLE
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    DE              shift and go to state 173
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 162

    (54) statement -> FOR L_PAREN NAME WO value KARA value . MADE NUMBER ZUTSU INCREASE R_PAREN
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    MADE            shift and go to state 174
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 163

    (32) statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 32 (statement -> TYPE COLON NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 164

    (33) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN . args R_PAREN
    (26) args -> .
    (27) args -> . value args_m
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_PAREN         reduce using rule 26 (args -> .)
    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    args                           shift and go to state 175
    value                          shift and go to state 51

state 165

    (9) init_array -> L_C_BRACKET R_C_BRACKET .

    $end            reduce using rule 9 (init_array -> L_C_BRACKET R_C_BRACKET .)


state 166

    (10) init_array -> L_C_BRACKET init_array_val . R_C_BRACKET
    (11) init_array_val -> init_array_val . COMMA value

    R_C_BRACKET     shift and go to state 176
    COMMA           shift and go to state 177


state 167

    (13) init_array -> L_C_BRACKET value . KO NO UNDEF NO VALUE R_C_BRACKET
    (12) init_array_val -> value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    KO              shift and go to state 178
    R_C_BRACKET     reduce using rule 12 (init_array_val -> value .)
    COMMA           reduce using rule 12 (init_array_val -> value .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 168

    (34) statement -> NAME NO END NI NAME L_PAREN args R_PAREN . NO RETURN_VAL WO ADD

    NO              shift and go to state 179


state 169

    (20) params_m -> COMMA TYPE . COLON NAME params_m
    (21) params_m -> COMMA TYPE . NO ARRAY COLON NAME params_m

    COLON           shift and go to state 180
    NO              shift and go to state 181


state 170

    (19) params -> TYPE NO ARRAY COLON NAME . params_m
    (20) params_m -> . COMMA TYPE COLON NAME params_m
    (21) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (22) params_m -> .

    COMMA           shift and go to state 155
    R_PAREN         reduce using rule 22 (params_m -> .)

    params_m                       shift and go to state 182

state 171

    (25) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params . R_PAREN

    R_PAREN         shift and go to state 183


state 172

    (74) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP . VALUE

    VALUE           shift and go to state 184


state 173

    (53) conditional -> value GA value TO value DE . DIVISIBLE

    DIVISIBLE       shift and go to state 185


state 174

    (54) statement -> FOR L_PAREN NAME WO value KARA value MADE . NUMBER ZUTSU INCREASE R_PAREN

    NUMBER          shift and go to state 186


state 175

    (33) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args . R_PAREN

    R_PAREN         shift and go to state 187


state 176

    (10) init_array -> L_C_BRACKET init_array_val R_C_BRACKET .

    $end            reduce using rule 10 (init_array -> L_C_BRACKET init_array_val R_C_BRACKET .)


state 177

    (11) init_array_val -> init_array_val COMMA . value
    (35) value -> . POW L_PAREN args R_PAREN
    (58) value -> . NUMBER
    (59) value -> . FLOAT
    (60) value -> . NAME
    (61) value -> . STRING
    (62) value -> . NAME L_S_BRACKET value R_S_BRACKET
    (63) value -> . NAME L_S_BRACKET value R_S_BRACKET NO VALUE
    (64) value -> . NAME NO ARR_LEN
    (65) value -> . L_PAREN value R_PAREN
    (66) value -> . L_PAREN value R_PAREN NO RESULT
    (67) value -> . value PLUS value
    (68) value -> . value MINUS value
    (69) value -> . value MULTI value
    (70) value -> . value DIVID value division_tail
    (73) value -> . value NO DECIMAL_P BELOW WO ROUNDED_UP VALUE
    (74) value -> . L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    POW             shift and go to state 17
    NUMBER          shift and go to state 13
    FLOAT           shift and go to state 18
    NAME            shift and go to state 35
    STRING          shift and go to state 19
    L_PAREN         shift and go to state 6

    value                          shift and go to state 188

state 178

    (13) init_array -> L_C_BRACKET value KO . NO UNDEF NO VALUE R_C_BRACKET

    NO              shift and go to state 189


state 179

    (34) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO . RETURN_VAL WO ADD

    RETURN_VAL      shift and go to state 190


state 180

    (20) params_m -> COMMA TYPE COLON . NAME params_m

    NAME            shift and go to state 191


state 181

    (21) params_m -> COMMA TYPE NO . ARRAY COLON NAME params_m

    ARRAY           shift and go to state 192


state 182

    (19) params -> TYPE NO ARRAY COLON NAME params_m .

    R_PAREN         reduce using rule 19 (params -> TYPE NO ARRAY COLON NAME params_m .)


state 183

    (25) statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN .

    $end            reduce using rule 25 (statement -> CIRCLE TYPE NO ARRAY COLON NAME L_PAREN params R_PAREN .)


state 184

    (74) value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .

    WO              reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    PLUS            reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MINUS           reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MULTI           reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DIVID           reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NO              reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_PAREN         reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    $end            reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_S_BRACKET     reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    COMMA           reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GA              reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    EQUAL           reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT             reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    NOT2            reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS            reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    LESS_EQUAL      reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER         reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    GREATER_EQUAL   reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    DE              reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    TO              reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KARA            reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    MADE            reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    KO              reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)
    R_C_BRACKET     reduce using rule 74 (value -> L_PAREN value R_PAREN NO DECIMAL_P BELOW WO ROUNDED_UP VALUE .)


state 185

    (53) conditional -> value GA value TO value DE DIVISIBLE .

    R_PAREN         reduce using rule 53 (conditional -> value GA value TO value DE DIVISIBLE .)


state 186

    (54) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER . ZUTSU INCREASE R_PAREN

    ZUTSU           shift and go to state 193


state 187

    (33) statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN .

    $end            reduce using rule 33 (statement -> TYPE NO ARRAY COLON NAME ASSIGN NAME L_PAREN args R_PAREN .)


state 188

    (11) init_array_val -> init_array_val COMMA value .
    (67) value -> value . PLUS value
    (68) value -> value . MINUS value
    (69) value -> value . MULTI value
    (70) value -> value . DIVID value division_tail
    (73) value -> value . NO DECIMAL_P BELOW WO ROUNDED_UP VALUE

    R_C_BRACKET     reduce using rule 11 (init_array_val -> init_array_val COMMA value .)
    COMMA           reduce using rule 11 (init_array_val -> init_array_val COMMA value .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULTI           shift and go to state 29
    DIVID           shift and go to state 30
    NO              shift and go to state 31


state 189

    (13) init_array -> L_C_BRACKET value KO NO . UNDEF NO VALUE R_C_BRACKET

    UNDEF           shift and go to state 194


state 190

    (34) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL . WO ADD

    WO              shift and go to state 195


state 191

    (20) params_m -> COMMA TYPE COLON NAME . params_m
    (20) params_m -> . COMMA TYPE COLON NAME params_m
    (21) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (22) params_m -> .

    COMMA           shift and go to state 155
    R_PAREN         reduce using rule 22 (params_m -> .)

    params_m                       shift and go to state 196

state 192

    (21) params_m -> COMMA TYPE NO ARRAY . COLON NAME params_m

    COLON           shift and go to state 197


state 193

    (54) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU . INCREASE R_PAREN

    INCREASE        shift and go to state 198


state 194

    (13) init_array -> L_C_BRACKET value KO NO UNDEF . NO VALUE R_C_BRACKET

    NO              shift and go to state 199


state 195

    (34) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO . ADD

    ADD             shift and go to state 200


state 196

    (20) params_m -> COMMA TYPE COLON NAME params_m .

    R_PAREN         reduce using rule 20 (params_m -> COMMA TYPE COLON NAME params_m .)


state 197

    (21) params_m -> COMMA TYPE NO ARRAY COLON . NAME params_m

    NAME            shift and go to state 201


state 198

    (54) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU INCREASE . R_PAREN

    R_PAREN         shift and go to state 202


state 199

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO . VALUE R_C_BRACKET

    VALUE           shift and go to state 203


state 200

    (34) statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD .

    $end            reduce using rule 34 (statement -> NAME NO END NI NAME L_PAREN args R_PAREN NO RETURN_VAL WO ADD .)


state 201

    (21) params_m -> COMMA TYPE NO ARRAY COLON NAME . params_m
    (20) params_m -> . COMMA TYPE COLON NAME params_m
    (21) params_m -> . COMMA TYPE NO ARRAY COLON NAME params_m
    (22) params_m -> .

    COMMA           shift and go to state 155
    R_PAREN         reduce using rule 22 (params_m -> .)

    params_m                       shift and go to state 204

state 202

    (54) statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN .

    $end            reduce using rule 54 (statement -> FOR L_PAREN NAME WO value KARA value MADE NUMBER ZUTSU INCREASE R_PAREN .)


state 203

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE . R_C_BRACKET

    R_C_BRACKET     shift and go to state 205


state 204

    (21) params_m -> COMMA TYPE NO ARRAY COLON NAME params_m .

    R_PAREN         reduce using rule 21 (params_m -> COMMA TYPE NO ARRAY COLON NAME params_m .)


state 205

    (13) init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .

    $end            reduce using rule 13 (init_array -> L_C_BRACKET value KO NO UNDEF NO VALUE R_C_BRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NO in state 3 resolved as shift
WARNING: shift/reduce conflict for NO in state 35 resolved as shift
WARNING: shift/reduce conflict for NO in state 45 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MULTI in state 56 resolved as shift
WARNING: shift/reduce conflict for DIVID in state 56 resolved as shift
WARNING: shift/reduce conflict for NO in state 56 resolved as shift
WARNING: shift/reduce conflict for NO in state 61 resolved as shift
WARNING: shift/reduce conflict for NO in state 75 resolved as shift
WARNING: shift/reduce conflict for NO in state 103 resolved as shift
WARNING: shift/reduce conflict for NO in state 110 resolved as shift
WARNING: shift/reduce conflict for NO in state 122 resolved as shift
